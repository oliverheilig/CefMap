using ErrorEventArgs = Newtonsoft.Json.Serialization.ErrorEventArgs;
using GeocodingClient.Client;
using GeocodingClient.Model;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using OpenAPIDateConverter = GeocodingClient.Client.OpenAPIDateConverter;
using Polly;
using RestSharp;
using RestSharp.Deserializers;
using RestSharpMethod = RestSharp.Method;
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Mime;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICategoriesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns the list of place categories.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlaceCategories</returns>
        PlaceCategories GetPlaceCategories(int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns the list of place categories.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlaceCategories</returns>
        ApiResponse<PlaceCategories> GetPlaceCategoriesWithHttpInfo(int operationIndex = 0);
        #endregion Synchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICategoriesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns the list of place categories.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlaceCategories</returns>
        System.Threading.Tasks.Task<PlaceCategories> GetPlaceCategoriesAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns the list of place categories.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlaceCategories)</returns>
        System.Threading.Tasks.Task<ApiResponse<PlaceCategories>> GetPlaceCategoriesWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICategoriesApi : ICategoriesApiSync, ICategoriesApiAsync
    {
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class CategoriesApi : ICategoriesApi
    {
        private GeocodingClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;
        /// <summary>
        /// Initializes a new instance of the <see cref="CategoriesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CategoriesApi() : this((string)null)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="CategoriesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CategoriesApi(string basePath)
        {
            this.Configuration = GeocodingClient.Client.Configuration.MergeConfigurations(
                GeocodingClient.Client.GlobalConfiguration.Instance,
                new GeocodingClient.Client.Configuration { BasePath = basePath }
            );
            this.Client = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="CategoriesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public CategoriesApi(GeocodingClient.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Configuration = GeocodingClient.Client.Configuration.MergeConfigurations(
                GeocodingClient.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="CategoriesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public CategoriesApi(GeocodingClient.Client.ISynchronousClient client, GeocodingClient.Client.IAsynchronousClient asyncClient, GeocodingClient.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public GeocodingClient.Client.IAsynchronousClient AsynchronousClient { get; set; }
        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public GeocodingClient.Client.ISynchronousClient Client { get; set; }
        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }
        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public GeocodingClient.Client.IReadableConfiguration Configuration { get; set; }
        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public GeocodingClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }
        /// <summary>
        ///  Returns the list of place categories.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlaceCategories</returns>
        public PlaceCategories GetPlaceCategories(int operationIndex = 0)
        {
            GeocodingClient.Client.ApiResponse<PlaceCategories> localVarResponse = GetPlaceCategoriesWithHttpInfo();
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Returns the list of place categories.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlaceCategories</returns>
        public GeocodingClient.Client.ApiResponse<PlaceCategories> GetPlaceCategoriesWithHttpInfo(int operationIndex = 0)
        {
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.Operation = "CategoriesApi.GetPlaceCategories";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<PlaceCategories>("/place-categories", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPlaceCategories", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Returns the list of place categories.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlaceCategories</returns>
        public async System.Threading.Tasks.Task<PlaceCategories> GetPlaceCategoriesAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.ApiResponse<PlaceCategories> localVarResponse = await GetPlaceCategoriesWithHttpInfoAsync(operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Returns the list of place categories.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlaceCategories)</returns>
        public async System.Threading.Tasks.Task<GeocodingClient.Client.ApiResponse<PlaceCategories>> GetPlaceCategoriesWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.Operation = "CategoriesApi.GetPlaceCategories";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PlaceCategories>("/place-categories", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPlaceCategories", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ILocationsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations based on a multi-field address input.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the locations should be searched. A country may be defined by name, ISO code (ISO 3166-1 alpha-2 or alpha-3) or country code plate. (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state, a region or a province. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It must not contain additional information like building names, floor numbers or apartment numbers. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LocationsSearchResult</returns>
        LocationsSearchResult SearchLocationsByAddress(string country = default(string), string state = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations based on a multi-field address input.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the locations should be searched. A country may be defined by name, ISO code (ISO 3166-1 alpha-2 or alpha-3) or country code plate. (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state, a region or a province. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It must not contain additional information like building names, floor numbers or apartment numbers. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LocationsSearchResult</returns>
        ApiResponse<LocationsSearchResult> SearchLocationsByAddressWithHttpInfo(string country = default(string), string state = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations near a given geographical position.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LocationsSearchResult</returns>
        LocationsSearchResult SearchLocationsByPosition(double latitude, double longitude, string language = default(string), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations near a given geographical position.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LocationsSearchResult</returns>
        ApiResponse<LocationsSearchResult> SearchLocationsByPositionWithHttpInfo(double latitude, double longitude, string language = default(string), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations based on a single-field text input.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a location.</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LocationsSearchResult</returns>
        LocationsSearchResult SearchLocationsByText(string searchText, List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations based on a single-field text input.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a location.</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LocationsSearchResult</returns>
        ApiResponse<LocationsSearchResult> SearchLocationsByTextWithHttpInfo(string searchText, List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0);
        #endregion Synchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ILocationsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations based on a multi-field address input.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the locations should be searched. A country may be defined by name, ISO code (ISO 3166-1 alpha-2 or alpha-3) or country code plate. (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state, a region or a province. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It must not contain additional information like building names, floor numbers or apartment numbers. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LocationsSearchResult</returns>
        System.Threading.Tasks.Task<LocationsSearchResult> SearchLocationsByAddressAsync(string country = default(string), string state = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations based on a multi-field address input.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the locations should be searched. A country may be defined by name, ISO code (ISO 3166-1 alpha-2 or alpha-3) or country code plate. (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state, a region or a province. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It must not contain additional information like building names, floor numbers or apartment numbers. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LocationsSearchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<LocationsSearchResult>> SearchLocationsByAddressWithHttpInfoAsync(string country = default(string), string state = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations near a given geographical position.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LocationsSearchResult</returns>
        System.Threading.Tasks.Task<LocationsSearchResult> SearchLocationsByPositionAsync(double latitude, double longitude, string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations near a given geographical position.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LocationsSearchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<LocationsSearchResult>> SearchLocationsByPositionWithHttpInfoAsync(double latitude, double longitude, string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations based on a single-field text input.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a location.</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LocationsSearchResult</returns>
        System.Threading.Tasks.Task<LocationsSearchResult> SearchLocationsByTextAsync(string searchText, List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for locations based on a single-field text input.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a location.</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LocationsSearchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<LocationsSearchResult>> SearchLocationsByTextWithHttpInfoAsync(string searchText, List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ILocationsApi : ILocationsApiSync, ILocationsApiAsync
    {
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class LocationsApi : ILocationsApi
    {
        private GeocodingClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public LocationsApi() : this((string)null)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public LocationsApi(string basePath)
        {
            this.Configuration = GeocodingClient.Client.Configuration.MergeConfigurations(
                GeocodingClient.Client.GlobalConfiguration.Instance,
                new GeocodingClient.Client.Configuration { BasePath = basePath }
            );
            this.Client = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public LocationsApi(GeocodingClient.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Configuration = GeocodingClient.Client.Configuration.MergeConfigurations(
                GeocodingClient.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public LocationsApi(GeocodingClient.Client.ISynchronousClient client, GeocodingClient.Client.IAsynchronousClient asyncClient, GeocodingClient.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public GeocodingClient.Client.IAsynchronousClient AsynchronousClient { get; set; }
        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public GeocodingClient.Client.ISynchronousClient Client { get; set; }
        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }
        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public GeocodingClient.Client.IReadableConfiguration Configuration { get; set; }
        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public GeocodingClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }
        /// <summary>
        ///  Searches for locations based on a multi-field address input.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the locations should be searched. A country may be defined by name, ISO code (ISO 3166-1 alpha-2 or alpha-3) or country code plate. (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state, a region or a province. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It must not contain additional information like building names, floor numbers or apartment numbers. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LocationsSearchResult</returns>
        public LocationsSearchResult SearchLocationsByAddress(string country = default(string), string state = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0)
        {
            GeocodingClient.Client.ApiResponse<LocationsSearchResult> localVarResponse = SearchLocationsByAddressWithHttpInfo(country, state, locality, postalCode, street, houseNumber, countryFilter, language);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for locations based on a multi-field address input.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the locations should be searched. A country may be defined by name, ISO code (ISO 3166-1 alpha-2 or alpha-3) or country code plate. (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state, a region or a province. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It must not contain additional information like building names, floor numbers or apartment numbers. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LocationsSearchResult</returns>
        public GeocodingClient.Client.ApiResponse<LocationsSearchResult> SearchLocationsByAddressWithHttpInfo(string country = default(string), string state = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0)
        {
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (country != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "country", country));
            }
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (locality != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "locality", locality));
            }
            if (postalCode != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "postalCode", postalCode));
            }
            if (street != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "street", street));
            }
            if (houseNumber != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "houseNumber", houseNumber));
            }
            if (countryFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("csv", "countryFilter", countryFilter));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Operation = "LocationsApi.SearchLocationsByAddress";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<LocationsSearchResult>("/locations/by-address", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchLocationsByAddress", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Searches for locations based on a multi-field address input.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the locations should be searched. A country may be defined by name, ISO code (ISO 3166-1 alpha-2 or alpha-3) or country code plate. (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state, a region or a province. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It must not contain additional information like building names, floor numbers or apartment numbers. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LocationsSearchResult</returns>
        public async System.Threading.Tasks.Task<LocationsSearchResult> SearchLocationsByAddressAsync(string country = default(string), string state = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.ApiResponse<LocationsSearchResult> localVarResponse = await SearchLocationsByAddressWithHttpInfoAsync(country, state, locality, postalCode, street, houseNumber, countryFilter, language, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for locations based on a multi-field address input.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the locations should be searched. A country may be defined by name, ISO code (ISO 3166-1 alpha-2 or alpha-3) or country code plate. (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state, a region or a province. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It must not contain additional information like building names, floor numbers or apartment numbers. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LocationsSearchResult)</returns>
        public async System.Threading.Tasks.Task<GeocodingClient.Client.ApiResponse<LocationsSearchResult>> SearchLocationsByAddressWithHttpInfoAsync(string country = default(string), string state = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (country != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "country", country));
            }
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (locality != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "locality", locality));
            }
            if (postalCode != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "postalCode", postalCode));
            }
            if (street != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "street", street));
            }
            if (houseNumber != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "houseNumber", houseNumber));
            }
            if (countryFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("csv", "countryFilter", countryFilter));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Operation = "LocationsApi.SearchLocationsByAddress";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<LocationsSearchResult>("/locations/by-address", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchLocationsByAddress", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Searches for locations near a given geographical position.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LocationsSearchResult</returns>
        public LocationsSearchResult SearchLocationsByPosition(double latitude, double longitude, string language = default(string), int operationIndex = 0)
        {
            GeocodingClient.Client.ApiResponse<LocationsSearchResult> localVarResponse = SearchLocationsByPositionWithHttpInfo(latitude, longitude, language);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for locations near a given geographical position.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LocationsSearchResult</returns>
        public GeocodingClient.Client.ApiResponse<LocationsSearchResult> SearchLocationsByPositionWithHttpInfo(double latitude, double longitude, string language = default(string), int operationIndex = 0)
        {
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("latitude", GeocodingClient.Client.ClientUtils.ParameterToString(latitude)); // path parameter
            localVarRequestOptions.PathParameters.Add("longitude", GeocodingClient.Client.ClientUtils.ParameterToString(longitude)); // path parameter
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Operation = "LocationsApi.SearchLocationsByPosition";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<LocationsSearchResult>("/locations/by-position/{latitude}/{longitude}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchLocationsByPosition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Searches for locations near a given geographical position.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LocationsSearchResult</returns>
        public async System.Threading.Tasks.Task<LocationsSearchResult> SearchLocationsByPositionAsync(double latitude, double longitude, string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.ApiResponse<LocationsSearchResult> localVarResponse = await SearchLocationsByPositionWithHttpInfoAsync(latitude, longitude, language, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for locations near a given geographical position.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LocationsSearchResult)</returns>
        public async System.Threading.Tasks.Task<GeocodingClient.Client.ApiResponse<LocationsSearchResult>> SearchLocationsByPositionWithHttpInfoAsync(double latitude, double longitude, string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("latitude", GeocodingClient.Client.ClientUtils.ParameterToString(latitude)); // path parameter
            localVarRequestOptions.PathParameters.Add("longitude", GeocodingClient.Client.ClientUtils.ParameterToString(longitude)); // path parameter
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Operation = "LocationsApi.SearchLocationsByPosition";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<LocationsSearchResult>("/locations/by-position/{latitude}/{longitude}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchLocationsByPosition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Searches for locations based on a single-field text input.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a location.</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>LocationsSearchResult</returns>
        public LocationsSearchResult SearchLocationsByText(string searchText, List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0)
        {
            GeocodingClient.Client.ApiResponse<LocationsSearchResult> localVarResponse = SearchLocationsByTextWithHttpInfo(searchText, countryFilter, language);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for locations based on a single-field text input.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a location.</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of LocationsSearchResult</returns>
        public GeocodingClient.Client.ApiResponse<LocationsSearchResult> SearchLocationsByTextWithHttpInfo(string searchText, List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0)
        {
            // verify the required parameter 'searchText' is set
            if (searchText == null)
            {
                throw new GeocodingClient.Client.ApiException(400, "Missing required parameter 'searchText' when calling LocationsApi->SearchLocationsByText");
            }
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "searchText", searchText));
            if (countryFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("csv", "countryFilter", countryFilter));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Operation = "LocationsApi.SearchLocationsByText";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<LocationsSearchResult>("/locations/by-text", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchLocationsByText", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Searches for locations based on a single-field text input.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a location.</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of LocationsSearchResult</returns>
        public async System.Threading.Tasks.Task<LocationsSearchResult> SearchLocationsByTextAsync(string searchText, List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.ApiResponse<LocationsSearchResult> localVarResponse = await SearchLocationsByTextWithHttpInfoAsync(searchText, countryFilter, language, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for locations based on a single-field text input.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a location.</param>
        /// <param name="countryFilter">A comma-separated list of country codes according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. The search will only consider data from countries with these codes. If no filter is specified, all countries are taken into account. However, empty values are not allowed.     If a given subdivision code is not supported, only the first two digits referring to the country is be considered in the search and a **warningCode** &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; is be returned with the response. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (LocationsSearchResult)</returns>
        public async System.Threading.Tasks.Task<GeocodingClient.Client.ApiResponse<LocationsSearchResult>> SearchLocationsByTextWithHttpInfoAsync(string searchText, List<string> countryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'searchText' is set
            if (searchText == null)
            {
                throw new GeocodingClient.Client.ApiException(400, "Missing required parameter 'searchText' when calling LocationsApi->SearchLocationsByText");
            }
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "searchText", searchText));
            if (countryFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("csv", "countryFilter", countryFilter));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Operation = "LocationsApi.SearchLocationsByText";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<LocationsSearchResult>("/locations/by-text", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchLocationsByText", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPlacesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places within a requested area.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="placesByAreaRequest"></param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        PlacesSearchResult SearchPlacesByArea(PlacesByAreaRequest placesByAreaRequest, List<string> categoryFilter = default(List<string>), string language = default(string), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places within a requested area.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="placesByAreaRequest"></param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        ApiResponse<PlacesSearchResult> SearchPlacesByAreaWithHttpInfo(PlacesByAreaRequest placesByAreaRequest, List<string> categoryFilter = default(List<string>), string language = default(string), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places near a given geographical position.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="radius">The search radius [m] around the given position. (optional, default to 1000)</param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="limit">Limits the number of results that are returned. (optional, default to 5)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        PlacesSearchResult SearchPlacesByPosition(double latitude, double longitude, int? radius = default(int?), List<string> categoryFilter = default(List<string>), int? limit = default(int?), string language = default(string), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places near a given geographical position.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="radius">The search radius [m] around the given position. (optional, default to 1000)</param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="limit">Limits the number of results that are returned. (optional, default to 5)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        ApiResponse<PlacesSearchResult> SearchPlacesByPositionWithHttpInfo(double latitude, double longitude, int? radius = default(int?), List<string> categoryFilter = default(List<string>), int? limit = default(int?), string language = default(string), int operationIndex = 0);
        #endregion Synchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPlacesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places within a requested area.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="placesByAreaRequest"></param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByAreaAsync(PlacesByAreaRequest placesByAreaRequest, List<string> categoryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places within a requested area.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="placesByAreaRequest"></param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<PlacesSearchResult>> SearchPlacesByAreaWithHttpInfoAsync(PlacesByAreaRequest placesByAreaRequest, List<string> categoryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places near a given geographical position.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="radius">The search radius [m] around the given position. (optional, default to 1000)</param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="limit">Limits the number of results that are returned. (optional, default to 5)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByPositionAsync(double latitude, double longitude, int? radius = default(int?), List<string> categoryFilter = default(List<string>), int? limit = default(int?), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places near a given geographical position.
        /// </remarks>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="radius">The search radius [m] around the given position. (optional, default to 1000)</param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="limit">Limits the number of results that are returned. (optional, default to 5)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<PlacesSearchResult>> SearchPlacesByPositionWithHttpInfoAsync(double latitude, double longitude, int? radius = default(int?), List<string> categoryFilter = default(List<string>), int? limit = default(int?), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPlacesApi : IPlacesApiSync, IPlacesApiAsync
    {
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class PlacesApi : IPlacesApi
    {
        private GeocodingClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;
        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PlacesApi() : this((string)null)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PlacesApi(string basePath)
        {
            this.Configuration = GeocodingClient.Client.Configuration.MergeConfigurations(
                GeocodingClient.Client.GlobalConfiguration.Instance,
                new GeocodingClient.Client.Configuration { BasePath = basePath }
            );
            this.Client = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public PlacesApi(GeocodingClient.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Configuration = GeocodingClient.Client.Configuration.MergeConfigurations(
                GeocodingClient.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeocodingClient.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public PlacesApi(GeocodingClient.Client.ISynchronousClient client, GeocodingClient.Client.IAsynchronousClient asyncClient, GeocodingClient.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = GeocodingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public GeocodingClient.Client.IAsynchronousClient AsynchronousClient { get; set; }
        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public GeocodingClient.Client.ISynchronousClient Client { get; set; }
        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }
        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public GeocodingClient.Client.IReadableConfiguration Configuration { get; set; }
        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public GeocodingClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }
        /// <summary>
        ///  Searches for places within a requested area.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="placesByAreaRequest"></param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        public PlacesSearchResult SearchPlacesByArea(PlacesByAreaRequest placesByAreaRequest, List<string> categoryFilter = default(List<string>), string language = default(string), int operationIndex = 0)
        {
            GeocodingClient.Client.ApiResponse<PlacesSearchResult> localVarResponse = SearchPlacesByAreaWithHttpInfo(placesByAreaRequest, categoryFilter, language);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for places within a requested area.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="placesByAreaRequest"></param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        public GeocodingClient.Client.ApiResponse<PlacesSearchResult> SearchPlacesByAreaWithHttpInfo(PlacesByAreaRequest placesByAreaRequest, List<string> categoryFilter = default(List<string>), string language = default(string), int operationIndex = 0)
        {
            // verify the required parameter 'placesByAreaRequest' is set
            if (placesByAreaRequest == null)
            {
                throw new GeocodingClient.Client.ApiException(400, "Missing required parameter 'placesByAreaRequest' when calling PlacesApi->SearchPlacesByArea");
            }
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
                "application/json"
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (categoryFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("csv", "categoryFilter", categoryFilter));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Data = placesByAreaRequest;
            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByArea";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Post<PlacesSearchResult>("/places/by-area", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByArea", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Searches for places within a requested area.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="placesByAreaRequest"></param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        public async System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByAreaAsync(PlacesByAreaRequest placesByAreaRequest, List<string> categoryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.ApiResponse<PlacesSearchResult> localVarResponse = await SearchPlacesByAreaWithHttpInfoAsync(placesByAreaRequest, categoryFilter, language, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for places within a requested area.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="placesByAreaRequest"></param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        public async System.Threading.Tasks.Task<GeocodingClient.Client.ApiResponse<PlacesSearchResult>> SearchPlacesByAreaWithHttpInfoAsync(PlacesByAreaRequest placesByAreaRequest, List<string> categoryFilter = default(List<string>), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'placesByAreaRequest' is set
            if (placesByAreaRequest == null)
            {
                throw new GeocodingClient.Client.ApiException(400, "Missing required parameter 'placesByAreaRequest' when calling PlacesApi->SearchPlacesByArea");
            }
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
                "application/json"
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (categoryFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("csv", "categoryFilter", categoryFilter));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Data = placesByAreaRequest;
            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByArea";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PlacesSearchResult>("/places/by-area", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByArea", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Searches for places near a given geographical position.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="radius">The search radius [m] around the given position. (optional, default to 1000)</param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="limit">Limits the number of results that are returned. (optional, default to 5)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        public PlacesSearchResult SearchPlacesByPosition(double latitude, double longitude, int? radius = default(int?), List<string> categoryFilter = default(List<string>), int? limit = default(int?), string language = default(string), int operationIndex = 0)
        {
            GeocodingClient.Client.ApiResponse<PlacesSearchResult> localVarResponse = SearchPlacesByPositionWithHttpInfo(latitude, longitude, radius, categoryFilter, limit, language);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for places near a given geographical position.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="radius">The search radius [m] around the given position. (optional, default to 1000)</param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="limit">Limits the number of results that are returned. (optional, default to 5)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        public GeocodingClient.Client.ApiResponse<PlacesSearchResult> SearchPlacesByPositionWithHttpInfo(double latitude, double longitude, int? radius = default(int?), List<string> categoryFilter = default(List<string>), int? limit = default(int?), string language = default(string), int operationIndex = 0)
        {
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("latitude", GeocodingClient.Client.ClientUtils.ParameterToString(latitude)); // path parameter
            localVarRequestOptions.PathParameters.Add("longitude", GeocodingClient.Client.ClientUtils.ParameterToString(longitude)); // path parameter
            if (radius != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "radius", radius));
            }
            if (categoryFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("csv", "categoryFilter", categoryFilter));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByPosition";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<PlacesSearchResult>("/places/by-position/{latitude}/{longitude}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByPosition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Searches for places near a given geographical position.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="radius">The search radius [m] around the given position. (optional, default to 1000)</param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="limit">Limits the number of results that are returned. (optional, default to 5)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        public async System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByPositionAsync(double latitude, double longitude, int? radius = default(int?), List<string> categoryFilter = default(List<string>), int? limit = default(int?), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.ApiResponse<PlacesSearchResult> localVarResponse = await SearchPlacesByPositionWithHttpInfoAsync(latitude, longitude, radius, categoryFilter, limit, language, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Searches for places near a given geographical position.
        /// </summary>
        /// <exception cref="GeocodingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="radius">The search radius [m] around the given position. (optional, default to 1000)</param>
        /// <param name="categoryFilter">A comma-separated list of place category IDs. Only results having one of these categories will be returned. If no filter is specified, all categories will be returned. However, empty values are not allowed. (optional)</param>
        /// <param name="limit">Limits the number of results that are returned. (optional, default to 5)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        public async System.Threading.Tasks.Task<GeocodingClient.Client.ApiResponse<PlacesSearchResult>> SearchPlacesByPositionWithHttpInfoAsync(double latitude, double longitude, int? radius = default(int?), List<string> categoryFilter = default(List<string>), int? limit = default(int?), string language = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            GeocodingClient.Client.RequestOptions localVarRequestOptions = new GeocodingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = GeocodingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = GeocodingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("latitude", GeocodingClient.Client.ClientUtils.ParameterToString(latitude)); // path parameter
            localVarRequestOptions.PathParameters.Add("longitude", GeocodingClient.Client.ClientUtils.ParameterToString(longitude)); // path parameter
            if (radius != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "radius", radius));
            }
            if (categoryFilter != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("csv", "categoryFilter", categoryFilter));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeocodingClient.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }
            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByPosition";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PlacesSearchResult>("/places/by-position/{latitude}/{longitude}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByPosition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Allows RestSharp to Serialize/Deserialize JSON using our custom logic, but only when ContentType is JSON.
    /// </summary>
    internal class CustomJsonCodec : RestSharp.Serializers.ISerializer, RestSharp.Deserializers.IDeserializer
    {
        private readonly IReadableConfiguration _configuration;
        private static readonly string _contentType = "application/json";
        private readonly JsonSerializerSettings _serializerSettings = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };
        public CustomJsonCodec(IReadableConfiguration configuration)
        {
            _configuration = configuration;
        }
        public CustomJsonCodec(JsonSerializerSettings serializerSettings, IReadableConfiguration configuration)
        {
            _serializerSettings = serializerSettings;
            _configuration = configuration;
        }
        /// <summary>
        /// Serialize the object into a JSON string.
        /// </summary>
        /// <param name="obj">Object to be serialized.</param>
        /// <returns>A JSON string.</returns>
        public string Serialize(object obj)
        {
            if (obj != null && obj is GeocodingClient.Model.AbstractOpenAPISchema)
            {
                // the object to be serialized is an oneOf/anyOf schema
                return ((GeocodingClient.Model.AbstractOpenAPISchema)obj).ToJson();
            }
            else
            {
                return JsonConvert.SerializeObject(obj, _serializerSettings);
            }
        }
        public T Deserialize<T>(IRestResponse response)
        {
            var result = (T)Deserialize(response, typeof(T));
            return result;
        }
        /// <summary>
        /// Deserialize the JSON string into a proper object.
        /// </summary>
        /// <param name="response">The HTTP response.</param>
        /// <param name="type">Object type.</param>
        /// <returns>Object representation of the JSON string.</returns>
        internal object Deserialize(IRestResponse response, Type type)
        {
            if (type == typeof(byte[])) // return byte array
            {
                return response.RawBytes;
            }
            // TODO: ? if (type.IsAssignableFrom(typeof(Stream)))
            if (type == typeof(Stream))
            {
                var bytes = response.RawBytes;
                if (response.Headers != null)
                {
                    var filePath = string.IsNullOrEmpty(_configuration.TempFolderPath)
                        ? Path.GetTempPath()
                        : _configuration.TempFolderPath;
                    var regex = new Regex(@"Content-Disposition=.*filename=['""]?([^'""\s]+)['""]?$");
                    foreach (var header in response.Headers)
                    {
                        var match = regex.Match(header.ToString());
                        if (match.Success)
                        {
                            string fileName = filePath + ClientUtils.SanitizeFilename(match.Groups[1].Value.Replace("\"", "").Replace("'", ""));
                            File.WriteAllBytes(fileName, bytes);
                            return new FileStream(fileName, FileMode.Open);
                        }
                    }
                }
                var stream = new MemoryStream(bytes);
                return stream;
            }
            if (type.Name.StartsWith("System.Nullable`1[[System.DateTime")) // return a datetime object
            {
                return DateTime.Parse(response.Content, null, System.Globalization.DateTimeStyles.RoundtripKind);
            }
            if (type == typeof(string) || type.Name.StartsWith("System.Nullable")) // return primitive type
            {
                return Convert.ChangeType(response.Content, type);
            }
            // at this point, it must be a model (json)
            try
            {
                return JsonConvert.DeserializeObject(response.Content, type, _serializerSettings);
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }
        public string RootElement { get; set; }
        public string Namespace { get; set; }
        public string DateFormat { get; set; }
        public string ContentType
        {
            get { return _contentType; }
            set { throw new InvalidOperationException("Not allowed to set content type."); }
        }
    }
    /// <summary>
    /// Provides a default implementation of an Api client (both synchronous and asynchronous implementations),
    /// encapsulating general REST accessor use cases.
    /// </summary>
    public partial class ApiClient : ISynchronousClient, IAsynchronousClient
    {
        private readonly string _baseUrl;
        /// <summary>
        /// Specifies the settings on a <see cref="JsonSerializer" /> object.
        /// These settings can be adjusted to accommodate custom serialization rules.
        /// </summary>
        public JsonSerializerSettings SerializerSettings { get; set; } = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };
        /// <summary>
        /// Allows for extending request processing for <see cref="ApiClient"/> generated code.
        /// </summary>
        /// <param name="request">The RestSharp request object</param>
        partial void InterceptRequest(IRestRequest request);
        /// <summary>
        /// Allows for extending response processing for <see cref="ApiClient"/> generated code.
        /// </summary>
        /// <param name="request">The RestSharp request object</param>
        /// <param name="response">The RestSharp response object</param>
        partial void InterceptResponse(IRestRequest request, IRestResponse response);
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiClient" />, defaulting to the global configurations' base url.
        /// </summary>
        public ApiClient()
        {
            _baseUrl = GeocodingClient.Client.GlobalConfiguration.Instance.BasePath;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiClient" />
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        public ApiClient(string basePath)
        {
            if (string.IsNullOrEmpty(basePath))
                throw new ArgumentException("basePath cannot be empty");
            _baseUrl = basePath;
        }
        /// <summary>
        /// Constructs the RestSharp version of an http method
        /// </summary>
        /// <param name="method">Swagger Client Custom HttpMethod</param>
        /// <returns>RestSharp's HttpMethod instance.</returns>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        private RestSharpMethod Method(HttpMethod method)
        {
            RestSharpMethod other;
            switch (method)
            {
                case HttpMethod.Get:
                    other = RestSharpMethod.GET;
                    break;
                case HttpMethod.Post:
                    other = RestSharpMethod.POST;
                    break;
                case HttpMethod.Put:
                    other = RestSharpMethod.PUT;
                    break;
                case HttpMethod.Delete:
                    other = RestSharpMethod.DELETE;
                    break;
                case HttpMethod.Head:
                    other = RestSharpMethod.HEAD;
                    break;
                case HttpMethod.Options:
                    other = RestSharpMethod.OPTIONS;
                    break;
                case HttpMethod.Patch:
                    other = RestSharpMethod.PATCH;
                    break;
                default:
                    throw new ArgumentOutOfRangeException("method", method, null);
            }
            return other;
        }
        /// <summary>
        /// Provides all logic for constructing a new RestSharp <see cref="RestRequest"/>.
        /// At this point, all information for querying the service is known. Here, it is simply
        /// mapped into the RestSharp request.
        /// </summary>
        /// <param name="method">The http verb.</param>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>[private] A new RestRequest instance.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        private RestRequest NewRequest(
            HttpMethod method,
            string path,
            RequestOptions options,
            IReadableConfiguration configuration)
        {
            if (path == null) throw new ArgumentNullException("path");
            if (options == null) throw new ArgumentNullException("options");
            if (configuration == null) throw new ArgumentNullException("configuration");
            RestRequest request = new RestRequest(Method(method))
            {
                Resource = path,
                JsonSerializer = new CustomJsonCodec(SerializerSettings, configuration)
            };
            if (options.PathParameters != null)
            {
                foreach (var pathParam in options.PathParameters)
                {
                    request.AddParameter(pathParam.Key, pathParam.Value, ParameterType.UrlSegment);
                }
            }
            if (options.QueryParameters != null)
            {
                foreach (var queryParam in options.QueryParameters)
                {
                    foreach (var value in queryParam.Value)
                    {
                        request.AddQueryParameter(queryParam.Key, value);
                    }
                }
            }
            if (configuration.DefaultHeaders != null)
            {
                foreach (var headerParam in configuration.DefaultHeaders)
                {
                    request.AddHeader(headerParam.Key, headerParam.Value);
                }
            }
            if (options.HeaderParameters != null)
            {
                foreach (var headerParam in options.HeaderParameters)
                {
                    foreach (var value in headerParam.Value)
                    {
                        request.AddHeader(headerParam.Key, value);
                    }
                }
            }
            if (options.FormParameters != null)
            {
                foreach (var formParam in options.FormParameters)
                {
                    request.AddParameter(formParam.Key, formParam.Value);
                }
            }
            if (options.Data != null)
            {
                if (options.Data is Stream stream)
                {
                    var contentType = "application/octet-stream";
                    if (options.HeaderParameters != null)
                    {
                        var contentTypes = options.HeaderParameters["Content-Type"];
                        contentType = contentTypes[0];
                    }
                    var bytes = ClientUtils.ReadAsBytes(stream);
                    request.AddParameter(contentType, bytes, ParameterType.RequestBody);
                }
                else
                {
                    if (options.HeaderParameters != null)
                    {
                        var contentTypes = options.HeaderParameters["Content-Type"];
                        if (contentTypes == null || contentTypes.Any(header => header.Contains("application/json")))
                        {
                            request.RequestFormat = DataFormat.Json;
                        }
                        else
                        {
                            // TODO: Generated client user should add additional handlers. RestSharp only supports XML and JSON, with XML as default.
                        }
                    }
                    else
                    {
                        // Here, we'll assume JSON APIs are more common. XML can be forced by adding produces/consumes to openapi spec explicitly.
                        request.RequestFormat = DataFormat.Json;
                    }
                    request.AddJsonBody(options.Data);
                }
            }
            if (options.FileParameters != null)
            {
                foreach (var fileParam in options.FileParameters)
                {
                    foreach (var file in fileParam.Value)
                    {
                        var bytes = ClientUtils.ReadAsBytes(file);
                        var fileStream = file as FileStream;
                        if (fileStream != null)
                            request.Files.Add(FileParameter.Create(fileParam.Key, bytes, System.IO.Path.GetFileName(fileStream.Name)));
                        else
                            request.Files.Add(FileParameter.Create(fileParam.Key, bytes, "no_file_name_provided"));
                    }
                }
            }
            if (options.Cookies != null && options.Cookies.Count > 0)
            {
                foreach (var cookie in options.Cookies)
                {
                    request.AddCookie(cookie.Name, cookie.Value);
                }
            }
            return request;
        }
        private ApiResponse<T> ToApiResponse<T>(IRestResponse<T> response)
        {
            T result = response.Data;
            string rawContent = response.Content;
            var transformed = new ApiResponse<T>(response.StatusCode, new Multimap<string, string>(), result, rawContent)
            {
                ErrorText = response.ErrorMessage,
                Cookies = new List<Cookie>()
            };
            if (response.Headers != null)
            {
                foreach (var responseHeader in response.Headers)
                {
                    transformed.Headers.Add(responseHeader.Name, ClientUtils.ParameterToString(responseHeader.Value));
                }
            }
            if (response.Cookies != null)
            {
                foreach (var responseCookies in response.Cookies)
                {
                    transformed.Cookies.Add(
                        new Cookie(
                            responseCookies.Name,
                            responseCookies.Value,
                            responseCookies.Path,
                            responseCookies.Domain)
                        );
                }
            }
            return transformed;
        }
        private ApiResponse<T> Exec<T>(RestRequest req, RequestOptions options, IReadableConfiguration configuration)
        {
            var baseUrl = configuration.GetOperationServerUrl(options.Operation, options.OperationIndex) ?? _baseUrl;
            RestClient client = new RestClient(baseUrl);
            client.ClearHandlers();
            var existingDeserializer = req.JsonSerializer as IDeserializer;
            if (existingDeserializer != null)
            {
                client.AddHandler("application/json", () => existingDeserializer);
                client.AddHandler("text/json", () => existingDeserializer);
                client.AddHandler("text/x-json", () => existingDeserializer);
                client.AddHandler("text/javascript", () => existingDeserializer);
                client.AddHandler("*+json", () => existingDeserializer);
            }
            else
            {
                var customDeserializer = new CustomJsonCodec(SerializerSettings, configuration);
                client.AddHandler("application/json", () => customDeserializer);
                client.AddHandler("text/json", () => customDeserializer);
                client.AddHandler("text/x-json", () => customDeserializer);
                client.AddHandler("text/javascript", () => customDeserializer);
                client.AddHandler("*+json", () => customDeserializer);
            }
            var xmlDeserializer = new XmlDeserializer();
            client.AddHandler("application/xml", () => xmlDeserializer);
            client.AddHandler("text/xml", () => xmlDeserializer);
            client.AddHandler("*+xml", () => xmlDeserializer);
            client.AddHandler("*", () => xmlDeserializer);
            client.Timeout = configuration.Timeout;
            if (configuration.Proxy != null)
            {
                client.Proxy = configuration.Proxy;
            }
            if (configuration.UserAgent != null)
            {
                client.UserAgent = configuration.UserAgent;
            }
            if (configuration.ClientCertificates != null)
            {
                client.ClientCertificates = configuration.ClientCertificates;
            }
            InterceptRequest(req);
            IRestResponse<T> response;
            if (RetryConfiguration.RetryPolicy != null)
            {
                var policy = RetryConfiguration.RetryPolicy;
                var policyResult = policy.ExecuteAndCapture(() => client.Execute(req));
                response = (policyResult.Outcome == OutcomeType.Successful) ? client.Deserialize<T>(policyResult.Result) : new RestResponse<T>
                {
                    Request = req,
                    ErrorException = policyResult.FinalException
                };
            }
            else
            {
                response = client.Execute<T>(req);
            }
            // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
            if (typeof(GeocodingClient.Model.AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
            {
                try
                {
                    response.Data = (T) typeof(T).GetMethod("FromJson").Invoke(null, new object[] { response.Content });
                }
                catch (Exception ex)
                {
                    throw ex.InnerException != null ? ex.InnerException : ex;
                }
            }
            else if (typeof(T).Name == "Stream") // for binary response
            {
                response.Data = (T)(object)new MemoryStream(response.RawBytes);
            }
            else if (typeof(T).Name == "Byte[]") // for byte response
            {
                response.Data = (T)(object)response.RawBytes;
            }
            InterceptResponse(req, response);
            var result = ToApiResponse(response);
            if (response.ErrorMessage != null)
            {
                result.ErrorText = response.ErrorMessage;
            }
            if (response.Cookies != null && response.Cookies.Count > 0)
            {
                if (result.Cookies == null) result.Cookies = new List<Cookie>();
                foreach (var restResponseCookie in response.Cookies)
                {
                    var cookie = new Cookie(
                        restResponseCookie.Name,
                        restResponseCookie.Value,
                        restResponseCookie.Path,
                        restResponseCookie.Domain
                    )
                    {
                        Comment = restResponseCookie.Comment,
                        CommentUri = restResponseCookie.CommentUri,
                        Discard = restResponseCookie.Discard,
                        Expired = restResponseCookie.Expired,
                        Expires = restResponseCookie.Expires,
                        HttpOnly = restResponseCookie.HttpOnly,
                        Port = restResponseCookie.Port,
                        Secure = restResponseCookie.Secure,
                        Version = restResponseCookie.Version
                    };
                    result.Cookies.Add(cookie);
                }
            }
            return result;
        }
        private async Task<ApiResponse<T>> ExecAsync<T>(RestRequest req, RequestOptions options, IReadableConfiguration configuration, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var baseUrl = configuration.GetOperationServerUrl(options.Operation, options.OperationIndex) ?? _baseUrl;
            RestClient client = new RestClient(baseUrl);
            client.ClearHandlers();
            var existingDeserializer = req.JsonSerializer as IDeserializer;
            if (existingDeserializer != null)
            {
                client.AddHandler("application/json", () => existingDeserializer);
                client.AddHandler("text/json", () => existingDeserializer);
                client.AddHandler("text/x-json", () => existingDeserializer);
                client.AddHandler("text/javascript", () => existingDeserializer);
                client.AddHandler("*+json", () => existingDeserializer);
            }
            else
            {
                var customDeserializer = new CustomJsonCodec(SerializerSettings, configuration);
                client.AddHandler("application/json", () => customDeserializer);
                client.AddHandler("text/json", () => customDeserializer);
                client.AddHandler("text/x-json", () => customDeserializer);
                client.AddHandler("text/javascript", () => customDeserializer);
                client.AddHandler("*+json", () => customDeserializer);
            }
            var xmlDeserializer = new XmlDeserializer();
            client.AddHandler("application/xml", () => xmlDeserializer);
            client.AddHandler("text/xml", () => xmlDeserializer);
            client.AddHandler("*+xml", () => xmlDeserializer);
            client.AddHandler("*", () => xmlDeserializer);
            client.Timeout = configuration.Timeout;
            if (configuration.Proxy != null)
            {
                client.Proxy = configuration.Proxy;
            }
            if (configuration.UserAgent != null)
            {
                client.UserAgent = configuration.UserAgent;
            }
            if (configuration.ClientCertificates != null)
            {
                client.ClientCertificates = configuration.ClientCertificates;
            }
            InterceptRequest(req);
            IRestResponse<T> response;
            if (RetryConfiguration.AsyncRetryPolicy != null)
            {
                var policy = RetryConfiguration.AsyncRetryPolicy;
                var policyResult = await policy.ExecuteAndCaptureAsync((ct) => client.ExecuteAsync(req, ct), cancellationToken).ConfigureAwait(false);
                response = (policyResult.Outcome == OutcomeType.Successful) ? client.Deserialize<T>(policyResult.Result) : new RestResponse<T>
                {
                    Request = req,
                    ErrorException = policyResult.FinalException
                };
            }
            else
            {
                response = await client.ExecuteAsync<T>(req, cancellationToken).ConfigureAwait(false);
            }
            // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
            if (typeof(GeocodingClient.Model.AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
            {
                response.Data = (T) typeof(T).GetMethod("FromJson").Invoke(null, new object[] { response.Content });
            }
            else if (typeof(T).Name == "Stream") // for binary response
            {
                response.Data = (T)(object)new MemoryStream(response.RawBytes);
            }
            else if (typeof(T).Name == "Byte[]") // for byte response
            {
                response.Data = (T)(object)response.RawBytes;
            }
            InterceptResponse(req, response);
            var result = ToApiResponse(response);
            if (response.ErrorMessage != null)
            {
                result.ErrorText = response.ErrorMessage;
            }
            if (response.Cookies != null && response.Cookies.Count > 0)
            {
                if (result.Cookies == null) result.Cookies = new List<Cookie>();
                foreach (var restResponseCookie in response.Cookies)
                {
                    var cookie = new Cookie(
                        restResponseCookie.Name,
                        restResponseCookie.Value,
                        restResponseCookie.Path,
                        restResponseCookie.Domain
                    )
                    {
                        Comment = restResponseCookie.Comment,
                        CommentUri = restResponseCookie.CommentUri,
                        Discard = restResponseCookie.Discard,
                        Expired = restResponseCookie.Expired,
                        Expires = restResponseCookie.Expires,
                        HttpOnly = restResponseCookie.HttpOnly,
                        Port = restResponseCookie.Port,
                        Secure = restResponseCookie.Secure,
                        Version = restResponseCookie.Version
                    };
                    result.Cookies.Add(cookie);
                }
            }
            return result;
        }
        #region IAsynchronousClient
        /// <summary>
        /// Make a HTTP GET request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Get, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP POST request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Post, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP PUT request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Put, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP DELETE request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Delete, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP HEAD request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Head, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP OPTION request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Options, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP PATCH request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Patch, path, options, config), options, config, cancellationToken);
        }
        #endregion IAsynchronousClient
        #region ISynchronousClient
        /// <summary>
        /// Make a HTTP GET request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Get<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Get, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP POST request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Post<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Post, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP PUT request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Put<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Put, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP DELETE request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Delete<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Delete, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP HEAD request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Head<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Head, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP OPTION request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Options<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Options, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP PATCH request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Patch<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Patch, path, options, config), options, config);
        }
        #endregion ISynchronousClient
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// API Exception
    /// </summary>
    public class ApiException : Exception
    {
        /// <summary>
        /// Gets or sets the error code (HTTP status code)
        /// </summary>
        /// <value>The error code (HTTP status code).</value>
        public int ErrorCode { get; set; }
        /// <summary>
        /// Gets or sets the error content (body json object)
        /// </summary>
        /// <value>The error content (Http response body).</value>
        public object ErrorContent { get; private set; }
        /// <summary>
        /// Gets or sets the HTTP headers
        /// </summary>
        /// <value>HTTP headers</value>
        public Multimap<string, string> Headers { get; private set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiException"/> class.
        /// </summary>
        public ApiException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiException"/> class.
        /// </summary>
        /// <param name="errorCode">HTTP status code.</param>
        /// <param name="message">Error message.</param>
        public ApiException(int errorCode, string message) : base(message)
        {
            this.ErrorCode = errorCode;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiException"/> class.
        /// </summary>
        /// <param name="errorCode">HTTP status code.</param>
        /// <param name="message">Error message.</param>
        /// <param name="errorContent">Error content.</param>
        /// <param name="headers">HTTP Headers.</param>
        public ApiException(int errorCode, string message, object errorContent = null, Multimap<string, string> headers = null) : base(message)
        {
            this.ErrorCode = errorCode;
            this.ErrorContent = errorContent;
            this.Headers = headers;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Provides a non-generic contract for the ApiResponse wrapper.
    /// </summary>
    public interface IApiResponse
    {
        /// <summary>
        /// The data type of <see cref="Content"/>
        /// </summary>
        Type ResponseType { get; }
        /// <summary>
        /// The content of this response
        /// </summary>
        Object Content { get; }
        /// <summary>
        /// Gets or sets the status code (HTTP status code)
        /// </summary>
        /// <value>The status code.</value>
        HttpStatusCode StatusCode { get; }
        /// <summary>
        /// Gets or sets the HTTP headers
        /// </summary>
        /// <value>HTTP headers</value>
        Multimap<string, string> Headers { get; }
        /// <summary>
        /// Gets or sets any error text defined by the calling client.
        /// </summary>
        string ErrorText { get; set; }
        /// <summary>
        /// Gets or sets any cookies passed along on the response.
        /// </summary>
        List<Cookie> Cookies { get; set; }
        /// <summary>
        /// The raw content of this response
        /// </summary>
        string RawContent { get; }
    }
    /// <summary>
    /// API Response
    /// </summary>
    public class ApiResponse<T> : IApiResponse
    {
        #region Properties
        /// <summary>
        /// Gets or sets the status code (HTTP status code)
        /// </summary>
        /// <value>The status code.</value>
        public HttpStatusCode StatusCode { get; }
        /// <summary>
        /// Gets or sets the HTTP headers
        /// </summary>
        /// <value>HTTP headers</value>
        public Multimap<string, string> Headers { get; }
        /// <summary>
        /// Gets or sets the data (parsed HTTP body)
        /// </summary>
        /// <value>The data.</value>
        public T Data { get; }
        /// <summary>
        /// Gets or sets any error text defined by the calling client.
        /// </summary>
        public string ErrorText { get; set; }
        /// <summary>
        /// Gets or sets any cookies passed along on the response.
        /// </summary>
        public List<Cookie> Cookies { get; set; }
        /// <summary>
        /// The content of this response
        /// </summary>
        public Type ResponseType
        {
            get { return typeof(T); }
        }
        /// <summary>
        /// The data type of <see cref="Content"/>
        /// </summary>
        public object Content
        {
            get { return Data; }
        }
        /// <summary>
        /// The raw content
        /// </summary>
        public string RawContent { get; }
        #endregion Properties
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="headers">HTTP headers.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        /// <param name="rawContent">Raw content.</param>
        public ApiResponse(HttpStatusCode statusCode, Multimap<string, string> headers, T data, string rawContent)
        {
            StatusCode = statusCode;
            Headers = headers;
            Data = data;
            RawContent = rawContent;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="headers">HTTP headers.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        public ApiResponse(HttpStatusCode statusCode, Multimap<string, string> headers, T data) : this(statusCode, headers, data, null)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        /// <param name="rawContent">Raw content.</param>
        public ApiResponse(HttpStatusCode statusCode, T data, string rawContent) : this(statusCode, null, data, rawContent)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        public ApiResponse(HttpStatusCode statusCode, T data) : this(statusCode, data, null)
        {
        }
        #endregion Constructors
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Utility functions providing some benefit to API client consumers.
    /// </summary>
    public static class ClientUtils
    {
        /// <summary>
        /// Sanitize filename by removing the path
        /// </summary>
        /// <param name="filename">Filename</param>
        /// <returns>Filename</returns>
        public static string SanitizeFilename(string filename)
        {
            Match match = Regex.Match(filename, @".*[/\\](.*)$");
            return match.Success ? match.Groups[1].Value : filename;
        }
        /// <summary>
        /// Convert params to key/value pairs.
        /// Use collectionFormat to properly format lists and collections.
        /// </summary>
        /// <param name="collectionFormat">The swagger-supported collection format, one of: csv, tsv, ssv, pipes, multi</param>
        /// <param name="name">Key name.</param>
        /// <param name="value">Value object.</param>
        /// <returns>A multimap of keys with 1..n associated values.</returns>
        public static Multimap<string, string> ParameterToMultiMap(string collectionFormat, string name, object value)
        {
            var parameters = new Multimap<string, string>();
            if (value is ICollection collection && collectionFormat == "multi")
            {
                foreach (var item in collection)
                {
                    parameters.Add(name, ParameterToString(item));
                }
            }
            else if (value is IDictionary dictionary)
            {
                if(collectionFormat == "deepObject") {
                    foreach (DictionaryEntry entry in dictionary)
                    {
                        parameters.Add(name + "[" + entry.Key + "]", ParameterToString(entry.Value));
                    }
                }
                else {
                    foreach (DictionaryEntry entry in dictionary)
                    {
                        parameters.Add(entry.Key.ToString(), ParameterToString(entry.Value));
                    }
                }
            }
            else
            {
                parameters.Add(name, ParameterToString(value));
            }
            return parameters;
        }
        /// <summary>
        /// If parameter is DateTime, output in a formatted string (default ISO 8601), customizable with Configuration.DateTime.
        /// If parameter is a list, join the list with ",".
        /// Otherwise just return the string.
        /// </summary>
        /// <param name="obj">The parameter (header, path, query, form).</param>
        /// <param name="configuration">An optional configuration instance, providing formatting options used in processing.</param>
        /// <returns>Formatted string.</returns>
        public static string ParameterToString(object obj, IReadableConfiguration configuration = null)
        {
            if (obj is DateTime dateTime)
                // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
                // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
                // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
                // For example: 2009-06-15T13:45:30.0000000
                return dateTime.ToString((configuration ?? GlobalConfiguration.Instance).DateTimeFormat);
            if (obj is DateTimeOffset dateTimeOffset)
                // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
                // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
                // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
                // For example: 2009-06-15T13:45:30.0000000
                return dateTimeOffset.ToString((configuration ?? GlobalConfiguration.Instance).DateTimeFormat);
            if (obj is bool boolean)
                return boolean ? "true" : "false";
            if (obj is ICollection collection)
                return string.Join(",", collection.Cast<object>());
            return Convert.ToString(obj, CultureInfo.InvariantCulture);
        }
        /// <summary>
        /// Encode string in base64 format.
        /// </summary>
        /// <param name="text">string to be encoded.</param>
        /// <returns>Encoded string.</returns>
        public static string Base64Encode(string text)
        {
            return Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(text));
        }
        /// <summary>
        /// Convert stream to byte array
        /// </summary>
        /// <param name="inputStream">Input stream to be converted</param>
        /// <returns>Byte array</returns>
        public static byte[] ReadAsBytes(Stream inputStream)
        {
            using (var ms = new MemoryStream())
            {
                inputStream.CopyTo(ms);
                return ms.ToArray();
            }
        }
        /// <summary>
        /// Select the Content-Type header's value from the given content-type array:
        /// if JSON type exists in the given array, use it;
        /// otherwise use the first one defined in 'consumes'
        /// </summary>
        /// <param name="contentTypes">The Content-Type array to select from.</param>
        /// <returns>The Content-Type header to use.</returns>
        public static string SelectHeaderContentType(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
                return null;
            foreach (var contentType in contentTypes)
            {
                if (IsJsonMime(contentType))
                    return contentType;
            }
            return contentTypes[0]; // use the first content type specified in 'consumes'
        }
        /// <summary>
        /// Select the Accept header's value from the given accepts array:
        /// if JSON exists in the given array, use it;
        /// otherwise use all of them (joining into a string)
        /// </summary>
        /// <param name="accepts">The accepts array to select from.</param>
        /// <returns>The Accept header to use.</returns>
        public static string SelectHeaderAccept(string[] accepts)
        {
            if (accepts.Length == 0)
                return null;
            if (accepts.Contains("application/json", StringComparer.OrdinalIgnoreCase))
                return "application/json";
            return string.Join(",", accepts);
        }
        /// <summary>
        /// Provides a case-insensitive check that a provided content type is a known JSON-like content type.
        /// </summary>
        public static readonly Regex JsonRegex = new Regex("(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$");
        /// <summary>
        /// Check if the given MIME is a JSON MIME.
        /// JSON MIME examples:
        ///    application/json
        ///    application/json; charset=UTF8
        ///    APPLICATION/JSON
        ///    application/vnd.company+json
        /// </summary>
        /// <param name="mime">MIME</param>
        /// <returns>Returns True if MIME type is json.</returns>
        public static bool IsJsonMime(string mime)
        {
            if (string.IsNullOrWhiteSpace(mime)) return false;
            return JsonRegex.IsMatch(mime) || mime.Equals("application/json-patch+json");
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Represents a set of configuration settings
    /// </summary>
    public class Configuration : IReadableConfiguration
    {
        #region Constants
        /// <summary>
        /// Version of the package.
        /// </summary>
        /// <value>Version of the package.</value>
        public const string Version = "1.0.0";
        /// <summary>
        /// Identifier for ISO 8601 DateTime Format
        /// </summary>
        /// <remarks>See https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8 for more information.</remarks>
        // ReSharper disable once InconsistentNaming
        public const string ISO8601_DATETIME_FORMAT = "o";
        #endregion Constants
        #region Static Members
        /// <summary>
        /// Default creation of exceptions for a given method name and response object
        /// </summary>
        public static readonly ExceptionFactory DefaultExceptionFactory = (methodName, response) =>
        {
            var status = (int)response.StatusCode;
            if (status >= 400)
            {
                return new ApiException(status,
                    string.Format("Error calling {0}: {1}", methodName, response.RawContent),
                    response.RawContent, response.Headers);
            }
            if (status == 0)
            {
                return new ApiException(status,
                    string.Format("Error calling {0}: {1}", methodName, response.ErrorText), response.ErrorText);
            }
            return null;
        };
        #endregion Static Members
        #region Private Members
        /// <summary>
        /// Defines the base path of the target API server.
        /// Example: http://localhost:3000/v1/
        /// </summary>
        private string _basePath;
        /// <summary>
        /// Gets or sets the API key based on the authentication name.
        /// This is the key and value comprising the "secret" for accessing an API.
        /// </summary>
        /// <value>The API key.</value>
        private IDictionary<string, string> _apiKey;
        /// <summary>
        /// Gets or sets the prefix (e.g. Token) of the API key based on the authentication name.
        /// </summary>
        /// <value>The prefix of the API key.</value>
        private IDictionary<string, string> _apiKeyPrefix;
        private string _dateTimeFormat = ISO8601_DATETIME_FORMAT;
        private string _tempFolderPath = Path.GetTempPath();
        /// <summary>
        /// Gets or sets the servers defined in the OpenAPI spec.
        /// </summary>
        /// <value>The servers</value>
        private IList<IReadOnlyDictionary<string, object>> _servers;
        /// <summary>
        /// Gets or sets the operation servers defined in the OpenAPI spec.
        /// </summary>
        /// <value>The operation servers</value>
        private IReadOnlyDictionary<string, List<IReadOnlyDictionary<string, object>>> _operationServers;
        #endregion Private Members
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="Configuration" /> class
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("ReSharper", "VirtualMemberCallInConstructor")]
        public Configuration()
        {
            Proxy = null;
            UserAgent = "OpenAPI-Generator/1.0.0/csharp";
            BasePath = "https://api.myptv.com/geocoding/v1";
            DefaultHeaders = new ConcurrentDictionary<string, string>();
            ApiKey = new ConcurrentDictionary<string, string>();
            ApiKeyPrefix = new ConcurrentDictionary<string, string>();
            Servers = new List<IReadOnlyDictionary<string, object>>()
            {
                {
                    new Dictionary<string, object> {
                        {"url", "https://api.myptv.com/geocoding/v1"},
                        {"description", "No description provided"},
                    }
                }
            };
            OperationServers = new Dictionary<string, List<IReadOnlyDictionary<string, object>>>()
            {
            };
            // Setting Timeout has side effects (forces ApiClient creation).
            Timeout = 100000;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="Configuration" /> class
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("ReSharper", "VirtualMemberCallInConstructor")]
        public Configuration(
            IDictionary<string, string> defaultHeaders,
            IDictionary<string, string> apiKey,
            IDictionary<string, string> apiKeyPrefix,
            string basePath = "https://api.myptv.com/geocoding/v1") : this()
        {
            if (string.IsNullOrWhiteSpace(basePath))
                throw new ArgumentException("The provided basePath is invalid.", "basePath");
            if (defaultHeaders == null)
                throw new ArgumentNullException("defaultHeaders");
            if (apiKey == null)
                throw new ArgumentNullException("apiKey");
            if (apiKeyPrefix == null)
                throw new ArgumentNullException("apiKeyPrefix");
            BasePath = basePath;
            foreach (var keyValuePair in defaultHeaders)
            {
                DefaultHeaders.Add(keyValuePair);
            }
            foreach (var keyValuePair in apiKey)
            {
                ApiKey.Add(keyValuePair);
            }
            foreach (var keyValuePair in apiKeyPrefix)
            {
                ApiKeyPrefix.Add(keyValuePair);
            }
        }
        #endregion Constructors
        #region Properties
        /// <summary>
        /// Gets or sets the base path for API access.
        /// </summary>
        public virtual string BasePath {
            get { return _basePath; }
            set { _basePath = value; }
        }
        /// <summary>
        /// Gets or sets the default header.
        /// </summary>
        [Obsolete("Use DefaultHeaders instead.")]
        public virtual IDictionary<string, string> DefaultHeader
        {
            get
            {
                return DefaultHeaders;
            }
            set
            {
                DefaultHeaders = value;
            }
        }
        /// <summary>
        /// Gets or sets the default headers.
        /// </summary>
        public virtual IDictionary<string, string> DefaultHeaders { get; set; }
        /// <summary>
        /// Gets or sets the HTTP timeout (milliseconds) of ApiClient. Default to 100000 milliseconds.
        /// </summary>
        public virtual int Timeout { get; set; }
        /// <summary>
        /// Gets or sets the proxy
        /// </summary>
        /// <value>Proxy.</value>
        public virtual WebProxy Proxy { get; set; }
        /// <summary>
        /// Gets or sets the HTTP user agent.
        /// </summary>
        /// <value>Http user agent.</value>
        public virtual string UserAgent { get; set; }
        /// <summary>
        /// Gets or sets the username (HTTP basic authentication).
        /// </summary>
        /// <value>The username.</value>
        public virtual string Username { get; set; }
        /// <summary>
        /// Gets or sets the password (HTTP basic authentication).
        /// </summary>
        /// <value>The password.</value>
        public virtual string Password { get; set; }
        /// <summary>
        /// Gets the API key with prefix.
        /// </summary>
        /// <param name="apiKeyIdentifier">API key identifier (authentication scheme).</param>
        /// <returns>API key with prefix.</returns>
        public string GetApiKeyWithPrefix(string apiKeyIdentifier)
        {
            string apiKeyValue;
            ApiKey.TryGetValue(apiKeyIdentifier, out apiKeyValue);
            string apiKeyPrefix;
            if (ApiKeyPrefix.TryGetValue(apiKeyIdentifier, out apiKeyPrefix))
            {
                return apiKeyPrefix + " " + apiKeyValue;
            }
            return apiKeyValue;
        }
        /// <summary>
        /// Gets or sets certificate collection to be sent with requests.
        /// </summary>
        /// <value>X509 Certificate collection.</value>
        public X509CertificateCollection ClientCertificates { get; set; }
        /// <summary>
        /// Gets or sets the access token for OAuth2 authentication.
        ///
        /// This helper property simplifies code generation.
        /// </summary>
        /// <value>The access token.</value>
        public virtual string AccessToken { get; set; }
        /// <summary>
        /// Gets or sets the temporary folder path to store the files downloaded from the server.
        /// </summary>
        /// <value>Folder path.</value>
        public virtual string TempFolderPath
        {
            get { return _tempFolderPath; }
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    _tempFolderPath = Path.GetTempPath();
                    return;
                }
                // create the directory if it does not exist
                if (!Directory.Exists(value))
                {
                    Directory.CreateDirectory(value);
                }
                // check if the path contains directory separator at the end
                if (value[value.Length - 1] == Path.DirectorySeparatorChar)
                {
                    _tempFolderPath = value;
                }
                else
                {
                    _tempFolderPath = value + Path.DirectorySeparatorChar;
                }
            }
        }
        /// <summary>
        /// Gets or sets the date time format used when serializing in the ApiClient
        /// By default, it's set to ISO 8601 - "o", for others see:
        /// https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx
        /// and https://msdn.microsoft.com/en-us/library/8kb3ddd4(v=vs.110).aspx
        /// No validation is done to ensure that the string you're providing is valid
        /// </summary>
        /// <value>The DateTimeFormat string</value>
        public virtual string DateTimeFormat
        {
            get { return _dateTimeFormat; }
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    // Never allow a blank or null string, go back to the default
                    _dateTimeFormat = ISO8601_DATETIME_FORMAT;
                    return;
                }
                // Caution, no validation when you choose date time format other than ISO 8601
                // Take a look at the above links
                _dateTimeFormat = value;
            }
        }
        /// <summary>
        /// Gets or sets the prefix (e.g. Token) of the API key based on the authentication name.
        ///
        /// Whatever you set here will be prepended to the value defined in AddApiKey.
        ///
        /// An example invocation here might be:
        /// <example>
        /// ApiKeyPrefix["Authorization"] = "Bearer";
        /// </example>
        ///  where ApiKey["Authorization"] would then be used to set the value of your bearer token.
        ///
        /// <remarks>
        /// OAuth2 workflows should set tokens via AccessToken.
        /// </remarks>
        /// </summary>
        /// <value>The prefix of the API key.</value>
        public virtual IDictionary<string, string> ApiKeyPrefix
        {
            get { return _apiKeyPrefix; }
            set
            {
                if (value == null)
                {
                    throw new InvalidOperationException("ApiKeyPrefix collection may not be null.");
                }
                _apiKeyPrefix = value;
            }
        }
        /// <summary>
        /// Gets or sets the API key based on the authentication name.
        /// </summary>
        /// <value>The API key.</value>
        public virtual IDictionary<string, string> ApiKey
        {
            get { return _apiKey; }
            set
            {
                if (value == null)
                {
                    throw new InvalidOperationException("ApiKey collection may not be null.");
                }
                _apiKey = value;
            }
        }
        /// <summary>
        /// Gets or sets the servers.
        /// </summary>
        /// <value>The servers.</value>
        public virtual IList<IReadOnlyDictionary<string, object>> Servers
        {
            get { return _servers; }
            set
            {
                if (value == null)
                {
                    throw new InvalidOperationException("Servers may not be null.");
                }
                _servers = value;
            }
        }
        /// <summary>
        /// Gets or sets the operation servers.
        /// </summary>
        /// <value>The operation servers.</value>
        public virtual IReadOnlyDictionary<string, List<IReadOnlyDictionary<string, object>>> OperationServers
        {
            get { return _operationServers; }
            set
            {
                if (value == null)
                {
                    throw new InvalidOperationException("Operation servers may not be null.");
                }
                _operationServers = value;
            }
        }
        /// <summary>
        /// Returns URL based on server settings without providing values
        /// for the variables
        /// </summary>
        /// <param name="index">Array index of the server settings.</param>
        /// <return>The server URL.</return>
        public string GetServerUrl(int index)
        {
            return GetServerUrl(Servers, index, null);
        }
        /// <summary>
        /// Returns URL based on server settings.
        /// </summary>
        /// <param name="index">Array index of the server settings.</param>
        /// <param name="inputVariables">Dictionary of the variables and the corresponding values.</param>
        /// <return>The server URL.</return>
        public string GetServerUrl(int index, Dictionary<string, string> inputVariables)
        {
            return GetServerUrl(Servers, index, inputVariables);
        }
        /// <summary>
        /// Returns URL based on operation server settings.
        /// </summary>
        /// <param name="operation">Operation associated with the request path.</param>
        /// <param name="index">Array index of the server settings.</param>
        /// <return>The operation server URL.</return>
        public string GetOperationServerUrl(string operation, int index)
        {
            return GetOperationServerUrl(operation, index, null);
        }
        /// <summary>
        /// Returns URL based on operation server settings.
        /// </summary>
        /// <param name="operation">Operation associated with the request path.</param>
        /// <param name="index">Array index of the server settings.</param>
        /// <param name="inputVariables">Dictionary of the variables and the corresponding values.</param>
        /// <return>The operation server URL.</return>
        public string GetOperationServerUrl(string operation, int index, Dictionary<string, string> inputVariables)
        {
            if (OperationServers.TryGetValue(operation, out var operationServer))
            {
                return GetServerUrl(operationServer, index, inputVariables);
            }
            return null;
        }
        /// <summary>
        /// Returns URL based on server settings.
        /// </summary>
        /// <param name="servers">Dictionary of server settings.</param>
        /// <param name="index">Array index of the server settings.</param>
        /// <param name="inputVariables">Dictionary of the variables and the corresponding values.</param>
        /// <return>The server URL.</return>
        private string GetServerUrl(IList<IReadOnlyDictionary<string, object>> servers, int index, Dictionary<string, string> inputVariables)
        {
            if (index < 0 || index >= servers.Count)
            {
                throw new InvalidOperationException($"Invalid index {index} when selecting the server. Must be less than {servers.Count}.");
            }
            if (inputVariables == null)
            {
                inputVariables = new Dictionary<string, string>();
            }
            IReadOnlyDictionary<string, object> server = servers[index];
            string url = (string)server["url"];
            if (server.ContainsKey("variables"))
            {
                // go through each variable and assign a value
                foreach (KeyValuePair<string, object> variable in (IReadOnlyDictionary<string, object>)server["variables"])
                {
                    IReadOnlyDictionary<string, object> serverVariables = (IReadOnlyDictionary<string, object>)(variable.Value);
                    if (inputVariables.ContainsKey(variable.Key))
                    {
                        if (((List<string>)serverVariables["enum_values"]).Contains(inputVariables[variable.Key]))
                        {
                            url = url.Replace("{" + variable.Key + "}", inputVariables[variable.Key]);
                        }
                        else
                        {
                            throw new InvalidOperationException($"The variable `{variable.Key}` in the server URL has invalid value #{inputVariables[variable.Key]}. Must be {(List<string>)serverVariables["enum_values"]}");
                        }
                    }
                    else
                    {
                        // use default value
                        url = url.Replace("{" + variable.Key + "}", (string)serverVariables["default_value"]);
                    }
                }
            }
            return url;
        }
        #endregion Properties
        #region Methods
        /// <summary>
        /// Returns a string with essential information for debugging.
        /// </summary>
        public static string ToDebugReport()
        {
            string report = "C# SDK (GeocodingClient) Debug Report:\n";
            report += "    OS: " + System.Environment.OSVersion + "\n";
            report += "    .NET Framework Version: " + System.Environment.Version  + "\n";
            report += "    Version of the API: 1.4\n";
            report += "    SDK Package Version: 1.0.0\n";
            return report;
        }
        /// <summary>
        /// Add Api Key Header.
        /// </summary>
        /// <param name="key">Api Key name.</param>
        /// <param name="value">Api Key value.</param>
        /// <returns></returns>
        public void AddApiKey(string key, string value)
        {
            ApiKey[key] = value;
        }
        /// <summary>
        /// Sets the API key prefix.
        /// </summary>
        /// <param name="key">Api Key name.</param>
        /// <param name="value">Api Key value.</param>
        public void AddApiKeyPrefix(string key, string value)
        {
            ApiKeyPrefix[key] = value;
        }
        #endregion Methods
        #region Static Members
        /// <summary>
        /// Merge configurations.
        /// </summary>
        /// <param name="first">First configuration.</param>
        /// <param name="second">Second configuration.</param>
        /// <return>Merged configuration.</return>
        public static IReadableConfiguration MergeConfigurations(IReadableConfiguration first, IReadableConfiguration second)
        {
            if (second == null) return first ?? GlobalConfiguration.Instance;
            Dictionary<string, string> apiKey = first.ApiKey.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            Dictionary<string, string> apiKeyPrefix = first.ApiKeyPrefix.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            Dictionary<string, string> defaultHeaders = first.DefaultHeaders.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            foreach (var kvp in second.ApiKey) apiKey[kvp.Key] = kvp.Value;
            foreach (var kvp in second.ApiKeyPrefix) apiKeyPrefix[kvp.Key] = kvp.Value;
            foreach (var kvp in second.DefaultHeaders) defaultHeaders[kvp.Key] = kvp.Value;
            var config = new Configuration
            {
                ApiKey = apiKey,
                ApiKeyPrefix = apiKeyPrefix,
                DefaultHeaders = defaultHeaders,
                BasePath = second.BasePath ?? first.BasePath,
                Timeout = second.Timeout,
                Proxy = second.Proxy ?? first.Proxy,
                UserAgent = second.UserAgent ?? first.UserAgent,
                Username = second.Username ?? first.Username,
                Password = second.Password ?? first.Password,
                AccessToken = second.AccessToken ?? first.AccessToken,
                TempFolderPath = second.TempFolderPath ?? first.TempFolderPath,
                DateTimeFormat = second.DateTimeFormat ?? first.DateTimeFormat,
                ClientCertificates = second.ClientCertificates ?? first.ClientCertificates,
            };
            return config;
        }
        #endregion Static Members
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// A delegate to ExceptionFactory method
    /// </summary>
    /// <param name="methodName">Method name</param>
    /// <param name="response">Response</param>
    /// <returns>Exceptions</returns>
    public delegate Exception ExceptionFactory(string methodName, IApiResponse response);
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// <see cref="GlobalConfiguration"/> provides a compile-time extension point for globally configuring
    /// API Clients.
    /// </summary>
    /// <remarks>
    /// A customized implementation via partial class may reside in another file and may
    /// be excluded from automatic generation via a .openapi-generator-ignore file.
    /// </remarks>
    public partial class GlobalConfiguration : Configuration
    {
        #region Private Members
        private static readonly object GlobalConfigSync = new { };
        private static IReadableConfiguration _globalConfiguration;
        #endregion Private Members
        #region Constructors
        /// <inheritdoc />
        private GlobalConfiguration()
        {
        }
        /// <inheritdoc />
        public GlobalConfiguration(IDictionary<string, string> defaultHeader, IDictionary<string, string> apiKey, IDictionary<string, string> apiKeyPrefix, string basePath = "http://localhost:3000/api") : base(defaultHeader, apiKey, apiKeyPrefix, basePath)
        {
        }
        static GlobalConfiguration()
        {
            Instance = new GlobalConfiguration();
        }
        #endregion Constructors
        /// <summary>
        /// Gets or sets the default Configuration.
        /// </summary>
        /// <value>Configuration.</value>
        public static IReadableConfiguration Instance
        {
            get { return _globalConfiguration; }
            set
            {
                lock (GlobalConfigSync)
                {
                    _globalConfiguration = value;
                }
            }
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Http methods supported by swagger
    /// </summary>
    public enum HttpMethod
    {
        /// <summary>HTTP GET request.</summary>
        Get,
        /// <summary>HTTP POST request.</summary>
        Post,
        /// <summary>HTTP PUT request.</summary>
        Put,
        /// <summary>HTTP DELETE request.</summary>
        Delete,
        /// <summary>HTTP HEAD request.</summary>
        Head,
        /// <summary>HTTP OPTIONS request.</summary>
        Options,
        /// <summary>HTTP PATCH request.</summary>
        Patch
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Represents configuration aspects required to interact with the API endpoints.
    /// </summary>
    public interface IApiAccessor
    {
        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        IReadableConfiguration Configuration { get; set; }
        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        string GetBasePath();
        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        ExceptionFactory ExceptionFactory { get; set; }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Contract for Asynchronous RESTful API interactions.
    ///
    /// This interface allows consumers to provide a custom API accessor client.
    /// </summary>
    public interface IAsynchronousClient
    {
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the GET http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the POST http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the PUT http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the DELETE http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the HEAD http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the OPTIONS http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the PATCH http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Represents a readable-only configuration contract.
    /// </summary>
    public interface IReadableConfiguration
    {
        /// <summary>
        /// Gets the access token.
        /// </summary>
        /// <value>Access token.</value>
        string AccessToken { get; }
        /// <summary>
        /// Gets the API key.
        /// </summary>
        /// <value>API key.</value>
        IDictionary<string, string> ApiKey { get; }
        /// <summary>
        /// Gets the API key prefix.
        /// </summary>
        /// <value>API key prefix.</value>
        IDictionary<string, string> ApiKeyPrefix { get; }
        /// <summary>
        /// Gets the base path.
        /// </summary>
        /// <value>Base path.</value>
        string BasePath { get; }
        /// <summary>
        /// Gets the date time format.
        /// </summary>
        /// <value>Date time format.</value>
        string DateTimeFormat { get; }
        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <value>Default header.</value>
        [Obsolete("Use DefaultHeaders instead.")]
        IDictionary<string, string> DefaultHeader { get; }
        /// <summary>
        /// Gets the default headers.
        /// </summary>
        /// <value>Default headers.</value>
        IDictionary<string, string> DefaultHeaders { get; }
        /// <summary>
        /// Gets the temp folder path.
        /// </summary>
        /// <value>Temp folder path.</value>
        string TempFolderPath { get; }
        /// <summary>
        /// Gets the HTTP connection timeout (in milliseconds)
        /// </summary>
        /// <value>HTTP connection timeout.</value>
        int Timeout { get; }
        /// <summary>
        /// Gets the proxy.
        /// </summary>
        /// <value>Proxy.</value>
        WebProxy Proxy { get; }
        /// <summary>
        /// Gets the user agent.
        /// </summary>
        /// <value>User agent.</value>
        string UserAgent { get; }
        /// <summary>
        /// Gets the username.
        /// </summary>
        /// <value>Username.</value>
        string Username { get; }
        /// <summary>
        /// Gets the password.
        /// </summary>
        /// <value>Password.</value>
        string Password { get; }
        /// <summary>
        /// Get the servers associated with the operation.
        /// </summary>
        /// <value>Operation servers.</value>
        IReadOnlyDictionary<string, List<IReadOnlyDictionary<string, object>>> OperationServers { get; }
        /// <summary>
        /// Gets the API key with prefix.
        /// </summary>
        /// <param name="apiKeyIdentifier">API key identifier (authentication scheme).</param>
        /// <returns>API key with prefix.</returns>
        string GetApiKeyWithPrefix(string apiKeyIdentifier);
        /// <summary>
        /// Gets the Operation server url at the provided index.
        /// </summary>
        /// <param name="operation">Operation server name.</param>
        /// <param name="index">Index of the operation server settings.</param>
        /// <returns></returns>
        string GetOperationServerUrl(string operation, int index);
        /// <summary>
        /// Gets certificate collection to be sent with requests.
        /// </summary>
        /// <value>X509 Certificate collection.</value>
        X509CertificateCollection ClientCertificates { get; }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Contract for Synchronous RESTful API interactions.
    ///
    /// This interface allows consumers to provide a custom API accessor client.
    /// </summary>
    public interface ISynchronousClient
    {
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the GET http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Get<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the POST http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Post<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the PUT http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Put<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the DELETE http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Delete<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the HEAD http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Head<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the OPTIONS http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Options<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the PATCH http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Patch<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// A dictionary in which one key has many associated values.
    /// </summary>
    /// <typeparam name="TKey">The type of the key</typeparam>
    /// <typeparam name="TValue">The type of the value associated with the key.</typeparam>
    public class Multimap<TKey, TValue> : IDictionary<TKey, IList<TValue>>
    {
        #region Private Fields
        private readonly Dictionary<TKey, IList<TValue>> _dictionary;
        #endregion Private Fields
        #region Constructors
        /// <summary>
        /// Empty Constructor.
        /// </summary>
        public Multimap()
        {
            _dictionary = new Dictionary<TKey, IList<TValue>>();
        }
        /// <summary>
        /// Constructor with comparer.
        /// </summary>
        /// <param name="comparer"></param>
        public Multimap(IEqualityComparer<TKey> comparer)
        {
            _dictionary = new Dictionary<TKey, IList<TValue>>(comparer);
        }
        #endregion Constructors
        #region Enumerators
        /// <summary>
        /// To get the enumerator.
        /// </summary>
        /// <returns>Enumerator</returns>
        public IEnumerator<KeyValuePair<TKey, IList<TValue>>> GetEnumerator()
        {
            return _dictionary.GetEnumerator();
        }
        /// <summary>
        /// To get the enumerator.
        /// </summary>
        /// <returns>Enumerator</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return _dictionary.GetEnumerator();
        }
        #endregion Enumerators
        #region Public Members
        /// <summary>
        /// Add values to Multimap
        /// </summary>
        /// <param name="item">Key value pair</param>
        public void Add(KeyValuePair<TKey, IList<TValue>> item)
        {
            if (!TryAdd(item.Key, item.Value))
                throw new InvalidOperationException("Could not add values to Multimap.");
        }
        /// <summary>
        /// Add Multimap to Multimap
        /// </summary>
        /// <param name="multimap">Multimap</param>
        public void Add(Multimap<TKey, TValue> multimap)
        {
            foreach (var item in multimap)
            {
                if (!TryAdd(item.Key, item.Value))
                    throw new InvalidOperationException("Could not add values to Multimap.");
            }
        }
        /// <summary>
        /// Clear Multimap
        /// </summary>
        public void Clear()
        {
            _dictionary.Clear();
        }
        /// <summary>
        /// Determines whether Multimap contains the specified item.
        /// </summary>
        /// <param name="item">Key value pair</param>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        /// <returns>true if the Multimap contains the item; otherwise, false.</returns>
        public bool Contains(KeyValuePair<TKey, IList<TValue>> item)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        ///  Copy items of the Multimap to an array,
        ///     starting at a particular array index.
        /// </summary>
        /// <param name="array">The array that is the destination of the items copied
        ///     from Multimap. The array must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        public void CopyTo(KeyValuePair<TKey, IList<TValue>>[] array, int arrayIndex)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Removes the specified item from the Multimap.
        /// </summary>
        /// <param name="item">Key value pair</param>
        /// <returns>true if the item is successfully removed; otherwise, false.</returns>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        public bool Remove(KeyValuePair<TKey, IList<TValue>> item)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Gets the number of items contained in the Multimap.
        /// </summary>
        public int Count => _dictionary.Count;
        /// <summary>
        /// Gets a value indicating whether the Multimap is read-only.
        /// </summary>
        public bool IsReadOnly => false;
        /// <summary>
        /// Adds an item with the provided key and value to the Multimap.
        /// </summary>
        /// <param name="key">The object to use as the key of the item to add.</param>
        /// <param name="value">The object to use as the value of the item to add.</param>
        /// <exception cref="InvalidOperationException">Thrown when couldn't add the value to Multimap.</exception>
        public void Add(TKey key, IList<TValue> value)
        {
            if (value != null && value.Count > 0)
            {
                if (_dictionary.TryGetValue(key, out var list))
                {
                    foreach (var k in value) list.Add(k);
                }
                else
                {
                    list = new List<TValue>(value);
                    if (!TryAdd(key, list))
                        throw new InvalidOperationException("Could not add values to Multimap.");
                }
            }
        }
        /// <summary>
        /// Determines whether the Multimap contains an item with the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the Multimap.</param>
        /// <returns>true if the Multimap contains an item with
        ///     the key; otherwise, false.</returns>
        public bool ContainsKey(TKey key)
        {
            return _dictionary.ContainsKey(key);
        }
        /// <summary>
        /// Removes item with the specified key from the Multimap.
        /// </summary>
        /// <param name="key">The key to locate in the Multimap.</param>
        /// <returns>true if the item is successfully removed; otherwise, false.</returns>
        public bool Remove(TKey key)
        {
            return TryRemove(key, out var _);
        }
        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key whose value to get.</param>
        /// <param name="value">When this method returns, the value associated with the specified key, if the
        ///     key is found; otherwise, the default value for the type of the value parameter.
        ///     This parameter is passed uninitialized.</param>
        /// <returns> true if the object that implements Multimap contains
        ///     an item with the specified key; otherwise, false.</returns>
        public bool TryGetValue(TKey key, out IList<TValue> value)
        {
            return _dictionary.TryGetValue(key, out value);
        }
        /// <summary>
        /// Gets or sets the item with the specified key.
        /// </summary>
        /// <param name="key">The key of the item to get or set.</param>
        /// <returns>The value of the specified key.</returns>
        public IList<TValue> this[TKey key]
        {
            get => _dictionary[key];
            set => _dictionary[key] = value;
        }
        /// <summary>
        /// Gets a System.Collections.Generic.ICollection containing the keys of the Multimap.
        /// </summary>
        public ICollection<TKey> Keys => _dictionary.Keys;
        /// <summary>
        /// Gets a System.Collections.Generic.ICollection containing the values of the Multimap.
        /// </summary>
        public ICollection<IList<TValue>> Values => _dictionary.Values;
        /// <summary>
        ///  Copy the items of the Multimap to an System.Array,
        ///     starting at a particular System.Array index.
        /// </summary>
        /// <param name="array">The one-dimensional System.Array that is the destination of the items copied
        ///     from Multimap. The System.Array must have zero-based indexing.</param>
        /// <param name="index">The zero-based index in array at which copying begins.</param>
        public void CopyTo(Array array, int index)
        {
            ((ICollection)_dictionary).CopyTo(array, index);
        }
        /// <summary>
        /// Adds an item with the provided key and value to the Multimap.
        /// </summary>
        /// <param name="key">The object to use as the key of the item to add.</param>
        /// <param name="value">The object to use as the value of the item to add.</param>
        /// <exception cref="InvalidOperationException">Thrown when couldn't add value to Multimap.</exception>
        public void Add(TKey key, TValue value)
        {
            if (value != null)
            {
                if (_dictionary.TryGetValue(key, out var list))
                {
                    list.Add(value);
                }
                else
                {
                    list = new List<TValue> { value };
                    if (!TryAdd(key, list))
                        throw new InvalidOperationException("Could not add value to Multimap.");
                }
            }
        }
        #endregion Public Members
        #region Private Members
        /**
         * Helper method to encapsulate generator differences between dictionary types.
         */
        private bool TryRemove(TKey key, out IList<TValue> value)
        {
            _dictionary.TryGetValue(key, out value);
            return _dictionary.Remove(key);
        }
        /**
         * Helper method to encapsulate generator differences between dictionary types.
         */
        private bool TryAdd(TKey key, IList<TValue> value)
        {
            try
            {
                _dictionary.Add(key, value);
            }
            catch (ArgumentException)
            {
                return false;
            }
            return true;
        }
        #endregion Private Members
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Formatter for 'date' openapi formats ss defined by full-date - RFC3339
    /// see https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#data-types
    /// </summary>
    public class OpenAPIDateConverter : IsoDateTimeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OpenAPIDateConverter" /> class.
        /// </summary>
        public OpenAPIDateConverter()
        {
            // full-date   = date-fullyear "-" date-month "-" date-mday
            DateTimeFormat = "yyyy-MM-dd";
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// A container for generalized request inputs. This type allows consumers to extend the request functionality
    /// by abstracting away from the default (built-in) request framework (e.g. RestSharp).
    /// </summary>
    public class RequestOptions
    {
        /// <summary>
        /// Parameters to be bound to path parts of the Request's URL
        /// </summary>
        public Dictionary<string, string> PathParameters { get; set; }
        /// <summary>
        /// Query parameters to be applied to the request.
        /// Keys may have 1 or more values associated.
        /// </summary>
        public Multimap<string, string> QueryParameters { get; set; }
        /// <summary>
        /// Header parameters to be applied to to the request.
        /// Keys may have 1 or more values associated.
        /// </summary>
        public Multimap<string, string> HeaderParameters { get; set; }
        /// <summary>
        /// Form parameters to be sent along with the request.
        /// </summary>
        public Dictionary<string, string> FormParameters { get; set; }
        /// <summary>
        /// File parameters to be sent along with the request.
        /// </summary>
        public Multimap<string, Stream> FileParameters { get; set; }
        /// <summary>
        /// Cookies to be sent along with the request.
        /// </summary>
        public List<Cookie> Cookies { get; set; }
        /// <summary>
        /// Operation associated with the request path.
        /// </summary>
        public string Operation { get; set; }
        /// <summary>
        /// Index associated with the operation.
        /// </summary>
        public int OperationIndex { get; set; }
        /// <summary>
        /// Any data associated with a request body.
        /// </summary>
        public Object Data { get; set; }
        /// <summary>
        /// Constructs a new instance of <see cref="RequestOptions"/>
        /// </summary>
        public RequestOptions()
        {
            PathParameters = new Dictionary<string, string>();
            QueryParameters = new Multimap<string, string>();
            HeaderParameters = new Multimap<string, string>();
            FormParameters = new Dictionary<string, string>();
            FileParameters = new Multimap<string, Stream>();
            Cookies = new List<Cookie>();
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Client
{
    /// <summary>
    /// Configuration class to set the polly retry policies to be applied to the requests.
    /// </summary>
    public static class RetryConfiguration
    {
        /// <summary>
        /// Retry policy
        /// </summary>
        public static Policy<IRestResponse> RetryPolicy { get; set; }
        /// <summary>
        /// Async retry policy
        /// </summary>
        public static AsyncPolicy<IRestResponse> AsyncRetryPolicy { get; set; }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    ///  Abstract base class for oneOf, anyOf schemas in the OpenAPI specification
    /// </summary>
    public abstract partial class AbstractOpenAPISchema
    {
        /// <summary>
        ///  Custom JSON serializer
        /// </summary>
        static public readonly JsonSerializerSettings SerializerSettings = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            MissingMemberHandling = MissingMemberHandling.Error,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };
        /// <summary>
        ///  Custom JSON serializer for objects with additional properties
        /// </summary>
        static public readonly JsonSerializerSettings AdditionalPropertiesSerializerSettings = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            MissingMemberHandling = MissingMemberHandling.Ignore,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };
        /// <summary>
        /// Gets or Sets the actual instance
        /// </summary>
        public abstract Object ActualInstance { get; set; }
        /// <summary>
        /// Gets or Sets IsNullable to indicate whether the instance is nullable
        /// </summary>
        public bool IsNullable { get; protected set; }
        /// <summary>
        /// Gets or Sets the schema type, which can be either `oneOf` or `anyOf`
        /// </summary>
        public string SchemaType { get; protected set; }
        /// <summary>
        /// Converts the instance into JSON string.
        /// </summary>
        public abstract string ToJson();
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// Represents the address of a geographical object. Whenever a string, such as a city or street name, is available in multiple languages, it is returned in the default language specified by the country in which an object is located. Most of the fields are optional, because addressing schemes vary strongly between countries.
    /// </summary>
    [DataContract(Name = "Address")]
    public partial class Address : IEquatable<Address>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Address" /> class.
        /// </summary>
        /// <param name="countryName">The country. In a response, it is represented by its full name (not abbreviated or encoded)..</param>
        /// <param name="state">The name of the principal country subdivision which the address belongs to (for example, a state in the USA, or a canton in Switzerland)..</param>
        /// <param name="province">The name of the second-level country subdivision which the address belongs to (for example, a county in the UK, or a province in Italy)..</param>
        /// <param name="postalCode">The postal code of the address..</param>
        /// <param name="city">The city of the address, i.e. the highest entity at the communal level which the address belongs to..</param>
        /// <param name="district">The district of the address, i.e. the entity below city..</param>
        /// <param name="subdistrict">The subdistrict of the address, i.e. the entity below district..</param>
        /// <param name="street">The street of the address..</param>
        /// <param name="houseNumber">The house number of the address..</param>
        public Address(string countryName = default(string), string state = default(string), string province = default(string), string postalCode = default(string), string city = default(string), string district = default(string), string subdistrict = default(string), string street = default(string), string houseNumber = default(string))
        {
            this.CountryName = countryName;
            this.State = state;
            this.Province = province;
            this.PostalCode = postalCode;
            this.City = city;
            this.District = district;
            this.Subdistrict = subdistrict;
            this.Street = street;
            this.HouseNumber = houseNumber;
        }
        /// <summary>
        /// The country. In a response, it is represented by its full name (not abbreviated or encoded).
        /// </summary>
        /// <value>The country. In a response, it is represented by its full name (not abbreviated or encoded).</value>
        [DataMember(Name = "countryName", EmitDefaultValue = false)]
        public string CountryName { get; set; }
        /// <summary>
        /// The name of the principal country subdivision which the address belongs to (for example, a state in the USA, or a canton in Switzerland).
        /// </summary>
        /// <value>The name of the principal country subdivision which the address belongs to (for example, a state in the USA, or a canton in Switzerland).</value>
        [DataMember(Name = "state", EmitDefaultValue = false)]
        public string State { get; set; }
        /// <summary>
        /// The name of the second-level country subdivision which the address belongs to (for example, a county in the UK, or a province in Italy).
        /// </summary>
        /// <value>The name of the second-level country subdivision which the address belongs to (for example, a county in the UK, or a province in Italy).</value>
        [DataMember(Name = "province", EmitDefaultValue = false)]
        public string Province { get; set; }
        /// <summary>
        /// The postal code of the address.
        /// </summary>
        /// <value>The postal code of the address.</value>
        [DataMember(Name = "postalCode", EmitDefaultValue = false)]
        public string PostalCode { get; set; }
        /// <summary>
        /// The city of the address, i.e. the highest entity at the communal level which the address belongs to.
        /// </summary>
        /// <value>The city of the address, i.e. the highest entity at the communal level which the address belongs to.</value>
        [DataMember(Name = "city", EmitDefaultValue = false)]
        public string City { get; set; }
        /// <summary>
        /// The district of the address, i.e. the entity below city.
        /// </summary>
        /// <value>The district of the address, i.e. the entity below city.</value>
        [DataMember(Name = "district", EmitDefaultValue = false)]
        public string District { get; set; }
        /// <summary>
        /// The subdistrict of the address, i.e. the entity below district.
        /// </summary>
        /// <value>The subdistrict of the address, i.e. the entity below district.</value>
        [DataMember(Name = "subdistrict", EmitDefaultValue = false)]
        public string Subdistrict { get; set; }
        /// <summary>
        /// The street of the address.
        /// </summary>
        /// <value>The street of the address.</value>
        [DataMember(Name = "street", EmitDefaultValue = false)]
        public string Street { get; set; }
        /// <summary>
        /// The house number of the address.
        /// </summary>
        /// <value>The house number of the address.</value>
        [DataMember(Name = "houseNumber", EmitDefaultValue = false)]
        public string HouseNumber { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Address {\n");
            sb.Append("  CountryName: ").Append(CountryName).Append("\n");
            sb.Append("  State: ").Append(State).Append("\n");
            sb.Append("  Province: ").Append(Province).Append("\n");
            sb.Append("  PostalCode: ").Append(PostalCode).Append("\n");
            sb.Append("  City: ").Append(City).Append("\n");
            sb.Append("  District: ").Append(District).Append("\n");
            sb.Append("  Subdistrict: ").Append(Subdistrict).Append("\n");
            sb.Append("  Street: ").Append(Street).Append("\n");
            sb.Append("  HouseNumber: ").Append(HouseNumber).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Address);
        }
        /// <summary>
        /// Returns true if Address instances are equal
        /// </summary>
        /// <param name="input">Instance of Address to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Address input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.CountryName == input.CountryName ||
                    (this.CountryName != null &&
                    this.CountryName.Equals(input.CountryName))
                ) && 
                (
                    this.State == input.State ||
                    (this.State != null &&
                    this.State.Equals(input.State))
                ) && 
                (
                    this.Province == input.Province ||
                    (this.Province != null &&
                    this.Province.Equals(input.Province))
                ) && 
                (
                    this.PostalCode == input.PostalCode ||
                    (this.PostalCode != null &&
                    this.PostalCode.Equals(input.PostalCode))
                ) && 
                (
                    this.City == input.City ||
                    (this.City != null &&
                    this.City.Equals(input.City))
                ) && 
                (
                    this.District == input.District ||
                    (this.District != null &&
                    this.District.Equals(input.District))
                ) && 
                (
                    this.Subdistrict == input.Subdistrict ||
                    (this.Subdistrict != null &&
                    this.Subdistrict.Equals(input.Subdistrict))
                ) && 
                (
                    this.Street == input.Street ||
                    (this.Street != null &&
                    this.Street.Equals(input.Street))
                ) && 
                (
                    this.HouseNumber == input.HouseNumber ||
                    (this.HouseNumber != null &&
                    this.HouseNumber.Equals(input.HouseNumber))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.CountryName != null)
                {
                    hashCode = (hashCode * 59) + this.CountryName.GetHashCode();
                }
                if (this.State != null)
                {
                    hashCode = (hashCode * 59) + this.State.GetHashCode();
                }
                if (this.Province != null)
                {
                    hashCode = (hashCode * 59) + this.Province.GetHashCode();
                }
                if (this.PostalCode != null)
                {
                    hashCode = (hashCode * 59) + this.PostalCode.GetHashCode();
                }
                if (this.City != null)
                {
                    hashCode = (hashCode * 59) + this.City.GetHashCode();
                }
                if (this.District != null)
                {
                    hashCode = (hashCode * 59) + this.District.GetHashCode();
                }
                if (this.Subdistrict != null)
                {
                    hashCode = (hashCode * 59) + this.Subdistrict.GetHashCode();
                }
                if (this.Street != null)
                {
                    hashCode = (hashCode * 59) + this.Street.GetHashCode();
                }
                if (this.HouseNumber != null)
                {
                    hashCode = (hashCode * 59) + this.HouseNumber.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// Defines the area as [GeoJSON](https://datatracker.ietf.org/doc/html/rfc7946) geometry. Supported geometry types are Polygon and MultiPolygon. Geometries that cause too long processing times will be rejected. In this case an error response is returned that explains the reason.
    /// </summary>
    [DataContract(Name = "Area")]
    public partial class Area : IEquatable<Area>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Area" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Area() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Area" /> class.
        /// </summary>
        /// <param name="geometry">geometry (required).</param>
        public Area(string geometry = default(string))
        {
            // to ensure "geometry" is required (not null)
            if (geometry == null)
            {
                throw new ArgumentNullException("geometry is a required property for Area and cannot be null");
            }
            this.Geometry = geometry;
        }
        /// <summary>
        /// Gets or Sets Geometry
        /// </summary>
        [DataMember(Name = "geometry", IsRequired = true, EmitDefaultValue = false)]
        public string Geometry { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Area {\n");
            sb.Append("  Geometry: ").Append(Geometry).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Area);
        }
        /// <summary>
        /// Returns true if Area instances are equal
        /// </summary>
        /// <param name="input">Instance of Area to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Area input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Geometry == input.Geometry ||
                    (this.Geometry != null &&
                    this.Geometry.Equals(input.Geometry))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Geometry != null)
                {
                    hashCode = (hashCode * 59) + this.Geometry.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// CausingError
    /// </summary>
    [DataContract(Name = "CausingError")]
    public partial class CausingError : IEquatable<CausingError>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CausingError" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CausingError() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CausingError" /> class.
        /// </summary>
        /// <param name="description">A human readable message that describes the error. (required).</param>
        /// <param name="errorCode">A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.   Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **Error codes for** &#x60;GENERAL_VALIDATION_ERROR&#x60; * &#x60;GENERAL_INVALID_VALUE&#x60; - A parameter is set to an invalid value.     * &#x60;value&#x60; - The invalid value.    * &#x60;GENERAL_UNRECOGNIZED_PARAMETER&#x60; - A parameter is unknown.   * &#x60;GENERAL_MISSING_PARAMETER&#x60; - A required parameter is missing.   * &#x60;GENERAL_DUPLICATE_PARAMETER&#x60; - A parameter is duplicated.   * &#x60;GENERAL_MINIMUM_VALUE_VIOLATED&#x60; - The minimum value restriction is violated.     * &#x60;minimumValue&#x60; - The minimum value (integer or double).   * &#x60;GENERAL_MAXIMUM_VALUE_VIOLATED&#x60; - The maximum value restriction is violated.     * &#x60;maximumValue&#x60; - The maximum value (integer or double).   * &#x60;GENERAL_MINIMUM_LENGTH_VIOLATED&#x60; - The minimum length is violated.     * &#x60;minimumLength&#x60; - The minimum length (integer).   * &#x60;GENERAL_MAXIMUM_LENGTH_VIOLATED&#x60; - The maximum length is violated.     * &#x60;maximumLength&#x60; - The maximum length (integer). (required).</param>
        /// <param name="_parameter">The name of the affected query or path parameter or a JSONPath to the affected property of the request..</param>
        /// <param name="details">Additional properties specific to this error class..</param>
        public CausingError(string description = default(string), string errorCode = default(string), string _parameter = default(string), Dictionary<string, string> details = default(Dictionary<string, string>))
        {
            // to ensure "description" is required (not null)
            if (description == null)
            {
                throw new ArgumentNullException("description is a required property for CausingError and cannot be null");
            }
            this.Description = description;
            // to ensure "errorCode" is required (not null)
            if (errorCode == null)
            {
                throw new ArgumentNullException("errorCode is a required property for CausingError and cannot be null");
            }
            this.ErrorCode = errorCode;
            this.Parameter = _parameter;
            this.Details = details;
        }
        /// <summary>
        /// A human readable message that describes the error.
        /// </summary>
        /// <value>A human readable message that describes the error.</value>
        [DataMember(Name = "description", IsRequired = true, EmitDefaultValue = false)]
        public string Description { get; set; }
        /// <summary>
        /// A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.   Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **Error codes for** &#x60;GENERAL_VALIDATION_ERROR&#x60; * &#x60;GENERAL_INVALID_VALUE&#x60; - A parameter is set to an invalid value.     * &#x60;value&#x60; - The invalid value.    * &#x60;GENERAL_UNRECOGNIZED_PARAMETER&#x60; - A parameter is unknown.   * &#x60;GENERAL_MISSING_PARAMETER&#x60; - A required parameter is missing.   * &#x60;GENERAL_DUPLICATE_PARAMETER&#x60; - A parameter is duplicated.   * &#x60;GENERAL_MINIMUM_VALUE_VIOLATED&#x60; - The minimum value restriction is violated.     * &#x60;minimumValue&#x60; - The minimum value (integer or double).   * &#x60;GENERAL_MAXIMUM_VALUE_VIOLATED&#x60; - The maximum value restriction is violated.     * &#x60;maximumValue&#x60; - The maximum value (integer or double).   * &#x60;GENERAL_MINIMUM_LENGTH_VIOLATED&#x60; - The minimum length is violated.     * &#x60;minimumLength&#x60; - The minimum length (integer).   * &#x60;GENERAL_MAXIMUM_LENGTH_VIOLATED&#x60; - The maximum length is violated.     * &#x60;maximumLength&#x60; - The maximum length (integer).
        /// </summary>
        /// <value>A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.   Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **Error codes for** &#x60;GENERAL_VALIDATION_ERROR&#x60; * &#x60;GENERAL_INVALID_VALUE&#x60; - A parameter is set to an invalid value.     * &#x60;value&#x60; - The invalid value.    * &#x60;GENERAL_UNRECOGNIZED_PARAMETER&#x60; - A parameter is unknown.   * &#x60;GENERAL_MISSING_PARAMETER&#x60; - A required parameter is missing.   * &#x60;GENERAL_DUPLICATE_PARAMETER&#x60; - A parameter is duplicated.   * &#x60;GENERAL_MINIMUM_VALUE_VIOLATED&#x60; - The minimum value restriction is violated.     * &#x60;minimumValue&#x60; - The minimum value (integer or double).   * &#x60;GENERAL_MAXIMUM_VALUE_VIOLATED&#x60; - The maximum value restriction is violated.     * &#x60;maximumValue&#x60; - The maximum value (integer or double).   * &#x60;GENERAL_MINIMUM_LENGTH_VIOLATED&#x60; - The minimum length is violated.     * &#x60;minimumLength&#x60; - The minimum length (integer).   * &#x60;GENERAL_MAXIMUM_LENGTH_VIOLATED&#x60; - The maximum length is violated.     * &#x60;maximumLength&#x60; - The maximum length (integer).</value>
        [DataMember(Name = "errorCode", IsRequired = true, EmitDefaultValue = false)]
        public string ErrorCode { get; set; }
        /// <summary>
        /// The name of the affected query or path parameter or a JSONPath to the affected property of the request.
        /// </summary>
        /// <value>The name of the affected query or path parameter or a JSONPath to the affected property of the request.</value>
        [DataMember(Name = "parameter", EmitDefaultValue = false)]
        public string Parameter { get; set; }
        /// <summary>
        /// Additional properties specific to this error class.
        /// </summary>
        /// <value>Additional properties specific to this error class.</value>
        [DataMember(Name = "details", EmitDefaultValue = false)]
        public Dictionary<string, string> Details { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CausingError {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ErrorCode: ").Append(ErrorCode).Append("\n");
            sb.Append("  Parameter: ").Append(Parameter).Append("\n");
            sb.Append("  Details: ").Append(Details).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CausingError);
        }
        /// <summary>
        /// Returns true if CausingError instances are equal
        /// </summary>
        /// <param name="input">Instance of CausingError to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CausingError input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.ErrorCode == input.ErrorCode ||
                    (this.ErrorCode != null &&
                    this.ErrorCode.Equals(input.ErrorCode))
                ) && 
                (
                    this.Parameter == input.Parameter ||
                    (this.Parameter != null &&
                    this.Parameter.Equals(input.Parameter))
                ) && 
                (
                    this.Details == input.Details ||
                    this.Details != null &&
                    input.Details != null &&
                    this.Details.SequenceEqual(input.Details)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.ErrorCode != null)
                {
                    hashCode = (hashCode * 59) + this.ErrorCode.GetHashCode();
                }
                if (this.Parameter != null)
                {
                    hashCode = (hashCode * 59) + this.Parameter.GetHashCode();
                }
                if (this.Details != null)
                {
                    hashCode = (hashCode * 59) + this.Details.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// ErrorResponse
    /// </summary>
    [DataContract(Name = "ErrorResponse")]
    public partial class ErrorResponse : IEquatable<ErrorResponse>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ErrorResponse" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ErrorResponse() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ErrorResponse" /> class.
        /// </summary>
        /// <param name="description">A human readable message that describes the error. (required).</param>
        /// <param name="errorCode">A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.    Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **HTTP status code: 400**   * &#x60;GENERAL_VALIDATION_ERROR&#x60; - The validation of the request failed. Details can be found in **causes**.   * &#x60;GENERAL_PARSING_ERROR&#x60; - The JSON syntax is invalid.    **HTTP status code: 401**   * &#x60;GENERAL_UNAUTHENTICATED&#x60; - Invalid or missing authentication credentials.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 403**   * &#x60;GENERAL_FORBIDDEN&#x60; - Insufficient access rights.   * &#x60;GENERAL_QUOTA_EXCEEDED&#x60; - The transaction limit is exceeded.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 404**   * &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60; - A requested resource does not exist.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 429**   * &#x60;GENERAL_RATE_LIMIT_EXCEEDED&#x60; - The rate limit is exceeded.    **HTTP status code: 500**   * &#x60;GENERAL_INTERNAL_SERVER_ERROR&#x60; - The request could not be processed due to an internal error.     * &#x60;message&#x60; - An additional error message.     * &#x60;hint&#x60; - A hint how to solve the problem.    **HTTP status code: 503**   * &#x60;GENERAL_SERVICE_UNAVAILABLE&#x60; - The service is temporarily unavailable. (required).</param>
        /// <param name="traceId">A unique identifier of the corresponding trace forest. It can be used to trace errors by the support. (required).</param>
        /// <param name="errorId">A unique identifier specific to this error instance. It can be used to trace errors by the support..</param>
        /// <param name="causes">A list of affected parameters and/or properties that caused this error..</param>
        /// <param name="details">Additional properties specific to this error class..</param>
        public ErrorResponse(string description = default(string), string errorCode = default(string), string traceId = default(string), string errorId = default(string), List<CausingError> causes = default(List<CausingError>), Dictionary<string, Object> details = default(Dictionary<string, Object>))
        {
            // to ensure "description" is required (not null)
            if (description == null)
            {
                throw new ArgumentNullException("description is a required property for ErrorResponse and cannot be null");
            }
            this.Description = description;
            // to ensure "errorCode" is required (not null)
            if (errorCode == null)
            {
                throw new ArgumentNullException("errorCode is a required property for ErrorResponse and cannot be null");
            }
            this.ErrorCode = errorCode;
            // to ensure "traceId" is required (not null)
            if (traceId == null)
            {
                throw new ArgumentNullException("traceId is a required property for ErrorResponse and cannot be null");
            }
            this.TraceId = traceId;
            this.ErrorId = errorId;
            this.Causes = causes;
            this.Details = details;
        }
        /// <summary>
        /// A human readable message that describes the error.
        /// </summary>
        /// <value>A human readable message that describes the error.</value>
        [DataMember(Name = "description", IsRequired = true, EmitDefaultValue = false)]
        public string Description { get; set; }
        /// <summary>
        /// A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.    Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **HTTP status code: 400**   * &#x60;GENERAL_VALIDATION_ERROR&#x60; - The validation of the request failed. Details can be found in **causes**.   * &#x60;GENERAL_PARSING_ERROR&#x60; - The JSON syntax is invalid.    **HTTP status code: 401**   * &#x60;GENERAL_UNAUTHENTICATED&#x60; - Invalid or missing authentication credentials.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 403**   * &#x60;GENERAL_FORBIDDEN&#x60; - Insufficient access rights.   * &#x60;GENERAL_QUOTA_EXCEEDED&#x60; - The transaction limit is exceeded.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 404**   * &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60; - A requested resource does not exist.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 429**   * &#x60;GENERAL_RATE_LIMIT_EXCEEDED&#x60; - The rate limit is exceeded.    **HTTP status code: 500**   * &#x60;GENERAL_INTERNAL_SERVER_ERROR&#x60; - The request could not be processed due to an internal error.     * &#x60;message&#x60; - An additional error message.     * &#x60;hint&#x60; - A hint how to solve the problem.    **HTTP status code: 503**   * &#x60;GENERAL_SERVICE_UNAVAILABLE&#x60; - The service is temporarily unavailable.
        /// </summary>
        /// <value>A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.    Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **HTTP status code: 400**   * &#x60;GENERAL_VALIDATION_ERROR&#x60; - The validation of the request failed. Details can be found in **causes**.   * &#x60;GENERAL_PARSING_ERROR&#x60; - The JSON syntax is invalid.    **HTTP status code: 401**   * &#x60;GENERAL_UNAUTHENTICATED&#x60; - Invalid or missing authentication credentials.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 403**   * &#x60;GENERAL_FORBIDDEN&#x60; - Insufficient access rights.   * &#x60;GENERAL_QUOTA_EXCEEDED&#x60; - The transaction limit is exceeded.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 404**   * &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60; - A requested resource does not exist.     * &#x60;message&#x60; - An additional error message.    **HTTP status code: 429**   * &#x60;GENERAL_RATE_LIMIT_EXCEEDED&#x60; - The rate limit is exceeded.    **HTTP status code: 500**   * &#x60;GENERAL_INTERNAL_SERVER_ERROR&#x60; - The request could not be processed due to an internal error.     * &#x60;message&#x60; - An additional error message.     * &#x60;hint&#x60; - A hint how to solve the problem.    **HTTP status code: 503**   * &#x60;GENERAL_SERVICE_UNAVAILABLE&#x60; - The service is temporarily unavailable.</value>
        [DataMember(Name = "errorCode", IsRequired = true, EmitDefaultValue = false)]
        public string ErrorCode { get; set; }
        /// <summary>
        /// A unique identifier of the corresponding trace forest. It can be used to trace errors by the support.
        /// </summary>
        /// <value>A unique identifier of the corresponding trace forest. It can be used to trace errors by the support.</value>
        [DataMember(Name = "traceId", IsRequired = true, EmitDefaultValue = false)]
        public string TraceId { get; set; }
        /// <summary>
        /// A unique identifier specific to this error instance. It can be used to trace errors by the support.
        /// </summary>
        /// <value>A unique identifier specific to this error instance. It can be used to trace errors by the support.</value>
        [DataMember(Name = "errorId", EmitDefaultValue = false)]
        public string ErrorId { get; set; }
        /// <summary>
        /// A list of affected parameters and/or properties that caused this error.
        /// </summary>
        /// <value>A list of affected parameters and/or properties that caused this error.</value>
        [DataMember(Name = "causes", EmitDefaultValue = false)]
        public List<CausingError> Causes { get; set; }
        /// <summary>
        /// Additional properties specific to this error class.
        /// </summary>
        /// <value>Additional properties specific to this error class.</value>
        [DataMember(Name = "details", EmitDefaultValue = false)]
        public Dictionary<string, Object> Details { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ErrorResponse {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ErrorCode: ").Append(ErrorCode).Append("\n");
            sb.Append("  TraceId: ").Append(TraceId).Append("\n");
            sb.Append("  ErrorId: ").Append(ErrorId).Append("\n");
            sb.Append("  Causes: ").Append(Causes).Append("\n");
            sb.Append("  Details: ").Append(Details).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ErrorResponse);
        }
        /// <summary>
        /// Returns true if ErrorResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of ErrorResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ErrorResponse input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.ErrorCode == input.ErrorCode ||
                    (this.ErrorCode != null &&
                    this.ErrorCode.Equals(input.ErrorCode))
                ) && 
                (
                    this.TraceId == input.TraceId ||
                    (this.TraceId != null &&
                    this.TraceId.Equals(input.TraceId))
                ) && 
                (
                    this.ErrorId == input.ErrorId ||
                    (this.ErrorId != null &&
                    this.ErrorId.Equals(input.ErrorId))
                ) && 
                (
                    this.Causes == input.Causes ||
                    this.Causes != null &&
                    input.Causes != null &&
                    this.Causes.SequenceEqual(input.Causes)
                ) && 
                (
                    this.Details == input.Details ||
                    this.Details != null &&
                    input.Details != null &&
                    this.Details.SequenceEqual(input.Details)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.ErrorCode != null)
                {
                    hashCode = (hashCode * 59) + this.ErrorCode.GetHashCode();
                }
                if (this.TraceId != null)
                {
                    hashCode = (hashCode * 59) + this.TraceId.GetHashCode();
                }
                if (this.ErrorId != null)
                {
                    hashCode = (hashCode * 59) + this.ErrorId.GetHashCode();
                }
                if (this.Causes != null)
                {
                    hashCode = (hashCode * 59) + this.Causes.GetHashCode();
                }
                if (this.Details != null)
                {
                    hashCode = (hashCode * 59) + this.Details.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// Location
    /// </summary>
    [DataContract(Name = "Location")]
    public partial class Location : IEquatable<Location>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets LocationType
        /// </summary>
        [DataMember(Name = "locationType", IsRequired = true, EmitDefaultValue = false)]
        public LocationType LocationType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Location" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Location() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Location" /> class.
        /// </summary>
        /// <param name="referencePosition">referencePosition (required).</param>
        /// <param name="roadAccessPosition">roadAccessPosition.</param>
        /// <param name="address">address (required).</param>
        /// <param name="formattedAddress">A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address..</param>
        /// <param name="locationType">locationType (required).</param>
        /// <param name="quality">quality (required).</param>
        public Location(ReferencePosition referencePosition = default(ReferencePosition), RoadAccessPosition roadAccessPosition = default(RoadAccessPosition), Address address = default(Address), string formattedAddress = default(string), LocationType locationType = default(LocationType), Quality quality = default(Quality))
        {
            // to ensure "referencePosition" is required (not null)
            if (referencePosition == null)
            {
                throw new ArgumentNullException("referencePosition is a required property for Location and cannot be null");
            }
            this.ReferencePosition = referencePosition;
            // to ensure "address" is required (not null)
            if (address == null)
            {
                throw new ArgumentNullException("address is a required property for Location and cannot be null");
            }
            this.Address = address;
            this.LocationType = locationType;
            // to ensure "quality" is required (not null)
            if (quality == null)
            {
                throw new ArgumentNullException("quality is a required property for Location and cannot be null");
            }
            this.Quality = quality;
            this.RoadAccessPosition = roadAccessPosition;
            this.FormattedAddress = formattedAddress;
        }
        /// <summary>
        /// Gets or Sets ReferencePosition
        /// </summary>
        [DataMember(Name = "referencePosition", IsRequired = true, EmitDefaultValue = false)]
        public ReferencePosition ReferencePosition { get; set; }
        /// <summary>
        /// Gets or Sets RoadAccessPosition
        /// </summary>
        [DataMember(Name = "roadAccessPosition", EmitDefaultValue = false)]
        public RoadAccessPosition RoadAccessPosition { get; set; }
        /// <summary>
        /// Gets or Sets Address
        /// </summary>
        [DataMember(Name = "address", IsRequired = true, EmitDefaultValue = false)]
        public Address Address { get; set; }
        /// <summary>
        /// A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address.
        /// </summary>
        /// <value>A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address.</value>
        [DataMember(Name = "formattedAddress", EmitDefaultValue = false)]
        public string FormattedAddress { get; set; }
        /// <summary>
        /// Gets or Sets Quality
        /// </summary>
        [DataMember(Name = "quality", IsRequired = true, EmitDefaultValue = false)]
        public Quality Quality { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Location {\n");
            sb.Append("  ReferencePosition: ").Append(ReferencePosition).Append("\n");
            sb.Append("  RoadAccessPosition: ").Append(RoadAccessPosition).Append("\n");
            sb.Append("  Address: ").Append(Address).Append("\n");
            sb.Append("  FormattedAddress: ").Append(FormattedAddress).Append("\n");
            sb.Append("  LocationType: ").Append(LocationType).Append("\n");
            sb.Append("  Quality: ").Append(Quality).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Location);
        }
        /// <summary>
        /// Returns true if Location instances are equal
        /// </summary>
        /// <param name="input">Instance of Location to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Location input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ReferencePosition == input.ReferencePosition ||
                    (this.ReferencePosition != null &&
                    this.ReferencePosition.Equals(input.ReferencePosition))
                ) && 
                (
                    this.RoadAccessPosition == input.RoadAccessPosition ||
                    (this.RoadAccessPosition != null &&
                    this.RoadAccessPosition.Equals(input.RoadAccessPosition))
                ) && 
                (
                    this.Address == input.Address ||
                    (this.Address != null &&
                    this.Address.Equals(input.Address))
                ) && 
                (
                    this.FormattedAddress == input.FormattedAddress ||
                    (this.FormattedAddress != null &&
                    this.FormattedAddress.Equals(input.FormattedAddress))
                ) && 
                (
                    this.LocationType == input.LocationType ||
                    this.LocationType.Equals(input.LocationType)
                ) && 
                (
                    this.Quality == input.Quality ||
                    (this.Quality != null &&
                    this.Quality.Equals(input.Quality))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ReferencePosition != null)
                {
                    hashCode = (hashCode * 59) + this.ReferencePosition.GetHashCode();
                }
                if (this.RoadAccessPosition != null)
                {
                    hashCode = (hashCode * 59) + this.RoadAccessPosition.GetHashCode();
                }
                if (this.Address != null)
                {
                    hashCode = (hashCode * 59) + this.Address.GetHashCode();
                }
                if (this.FormattedAddress != null)
                {
                    hashCode = (hashCode * 59) + this.FormattedAddress.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.LocationType.GetHashCode();
                if (this.Quality != null)
                {
                    hashCode = (hashCode * 59) + this.Quality.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// LocationAllOf
    /// </summary>
    [DataContract(Name = "Location_allOf")]
    public partial class LocationAllOf : IEquatable<LocationAllOf>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets LocationType
        /// </summary>
        [DataMember(Name = "locationType", IsRequired = true, EmitDefaultValue = false)]
        public LocationType LocationType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationAllOf" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected LocationAllOf() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationAllOf" /> class.
        /// </summary>
        /// <param name="locationType">locationType (required).</param>
        /// <param name="quality">quality (required).</param>
        public LocationAllOf(LocationType locationType = default(LocationType), Quality quality = default(Quality))
        {
            this.LocationType = locationType;
            // to ensure "quality" is required (not null)
            if (quality == null)
            {
                throw new ArgumentNullException("quality is a required property for LocationAllOf and cannot be null");
            }
            this.Quality = quality;
        }
        /// <summary>
        /// Gets or Sets Quality
        /// </summary>
        [DataMember(Name = "quality", IsRequired = true, EmitDefaultValue = false)]
        public Quality Quality { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class LocationAllOf {\n");
            sb.Append("  LocationType: ").Append(LocationType).Append("\n");
            sb.Append("  Quality: ").Append(Quality).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as LocationAllOf);
        }
        /// <summary>
        /// Returns true if LocationAllOf instances are equal
        /// </summary>
        /// <param name="input">Instance of LocationAllOf to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(LocationAllOf input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.LocationType == input.LocationType ||
                    this.LocationType.Equals(input.LocationType)
                ) && 
                (
                    this.Quality == input.Quality ||
                    (this.Quality != null &&
                    this.Quality.Equals(input.Quality))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.LocationType.GetHashCode();
                if (this.Quality != null)
                {
                    hashCode = (hashCode * 59) + this.Quality.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// LocationProperties
    /// </summary>
    [DataContract(Name = "LocationProperties")]
    public partial class LocationProperties : IEquatable<LocationProperties>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationProperties" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected LocationProperties() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationProperties" /> class.
        /// </summary>
        /// <param name="referencePosition">referencePosition (required).</param>
        /// <param name="roadAccessPosition">roadAccessPosition.</param>
        /// <param name="address">address (required).</param>
        /// <param name="formattedAddress">A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address..</param>
        public LocationProperties(ReferencePosition referencePosition = default(ReferencePosition), RoadAccessPosition roadAccessPosition = default(RoadAccessPosition), Address address = default(Address), string formattedAddress = default(string))
        {
            // to ensure "referencePosition" is required (not null)
            if (referencePosition == null)
            {
                throw new ArgumentNullException("referencePosition is a required property for LocationProperties and cannot be null");
            }
            this.ReferencePosition = referencePosition;
            // to ensure "address" is required (not null)
            if (address == null)
            {
                throw new ArgumentNullException("address is a required property for LocationProperties and cannot be null");
            }
            this.Address = address;
            this.RoadAccessPosition = roadAccessPosition;
            this.FormattedAddress = formattedAddress;
        }
        /// <summary>
        /// Gets or Sets ReferencePosition
        /// </summary>
        [DataMember(Name = "referencePosition", IsRequired = true, EmitDefaultValue = false)]
        public ReferencePosition ReferencePosition { get; set; }
        /// <summary>
        /// Gets or Sets RoadAccessPosition
        /// </summary>
        [DataMember(Name = "roadAccessPosition", EmitDefaultValue = false)]
        public RoadAccessPosition RoadAccessPosition { get; set; }
        /// <summary>
        /// Gets or Sets Address
        /// </summary>
        [DataMember(Name = "address", IsRequired = true, EmitDefaultValue = false)]
        public Address Address { get; set; }
        /// <summary>
        /// A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address.
        /// </summary>
        /// <value>A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address.</value>
        [DataMember(Name = "formattedAddress", EmitDefaultValue = false)]
        public string FormattedAddress { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class LocationProperties {\n");
            sb.Append("  ReferencePosition: ").Append(ReferencePosition).Append("\n");
            sb.Append("  RoadAccessPosition: ").Append(RoadAccessPosition).Append("\n");
            sb.Append("  Address: ").Append(Address).Append("\n");
            sb.Append("  FormattedAddress: ").Append(FormattedAddress).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as LocationProperties);
        }
        /// <summary>
        /// Returns true if LocationProperties instances are equal
        /// </summary>
        /// <param name="input">Instance of LocationProperties to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(LocationProperties input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ReferencePosition == input.ReferencePosition ||
                    (this.ReferencePosition != null &&
                    this.ReferencePosition.Equals(input.ReferencePosition))
                ) && 
                (
                    this.RoadAccessPosition == input.RoadAccessPosition ||
                    (this.RoadAccessPosition != null &&
                    this.RoadAccessPosition.Equals(input.RoadAccessPosition))
                ) && 
                (
                    this.Address == input.Address ||
                    (this.Address != null &&
                    this.Address.Equals(input.Address))
                ) && 
                (
                    this.FormattedAddress == input.FormattedAddress ||
                    (this.FormattedAddress != null &&
                    this.FormattedAddress.Equals(input.FormattedAddress))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ReferencePosition != null)
                {
                    hashCode = (hashCode * 59) + this.ReferencePosition.GetHashCode();
                }
                if (this.RoadAccessPosition != null)
                {
                    hashCode = (hashCode * 59) + this.RoadAccessPosition.GetHashCode();
                }
                if (this.Address != null)
                {
                    hashCode = (hashCode * 59) + this.Address.GetHashCode();
                }
                if (this.FormattedAddress != null)
                {
                    hashCode = (hashCode * 59) + this.FormattedAddress.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// The result of a locations search.
    /// </summary>
    [DataContract(Name = "LocationsSearchResult")]
    public partial class LocationsSearchResult : IEquatable<LocationsSearchResult>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationsSearchResult" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected LocationsSearchResult() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="LocationsSearchResult" /> class.
        /// </summary>
        /// <param name="locations">The found locations. (required).</param>
        /// <param name="warnings">A list of warnings concerning the validity of the result..</param>
        public LocationsSearchResult(List<Location> locations = default(List<Location>), List<Warning> warnings = default(List<Warning>))
        {
            // to ensure "locations" is required (not null)
            if (locations == null)
            {
                throw new ArgumentNullException("locations is a required property for LocationsSearchResult and cannot be null");
            }
            this.Locations = locations;
            this.Warnings = warnings;
        }
        /// <summary>
        /// The found locations.
        /// </summary>
        /// <value>The found locations.</value>
        [DataMember(Name = "locations", IsRequired = true, EmitDefaultValue = false)]
        public List<Location> Locations { get; set; }
        /// <summary>
        /// A list of warnings concerning the validity of the result.
        /// </summary>
        /// <value>A list of warnings concerning the validity of the result.</value>
        [DataMember(Name = "warnings", EmitDefaultValue = false)]
        public List<Warning> Warnings { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class LocationsSearchResult {\n");
            sb.Append("  Locations: ").Append(Locations).Append("\n");
            sb.Append("  Warnings: ").Append(Warnings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as LocationsSearchResult);
        }
        /// <summary>
        /// Returns true if LocationsSearchResult instances are equal
        /// </summary>
        /// <param name="input">Instance of LocationsSearchResult to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(LocationsSearchResult input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Locations == input.Locations ||
                    this.Locations != null &&
                    input.Locations != null &&
                    this.Locations.SequenceEqual(input.Locations)
                ) && 
                (
                    this.Warnings == input.Warnings ||
                    this.Warnings != null &&
                    input.Warnings != null &&
                    this.Warnings.SequenceEqual(input.Warnings)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Locations != null)
                {
                    hashCode = (hashCode * 59) + this.Locations.GetHashCode();
                }
                if (this.Warnings != null)
                {
                    hashCode = (hashCode * 59) + this.Warnings.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// Distinguishes different types of Locations:    * &#x60;LOCALITY&#x60; - Represents a locality (town, city or place).    * &#x60;POSTAL_CODE&#x60; - Represents a postal code area.    * &#x60;STREET&#x60; - Represents a street, or a section of a street.    * &#x60;EXACT_ADDRESS:&#x60; - An address that is contained exactly in the geocoding data.     * &#x60;INTERPOLATED_ADDRESS&#x60; - An address that was interpolated from an address range.     * &#x60;INTERSECTION&#x60; - An at-grade junction where two streets meet.     * &#x60;POINT_OF_INTEREST&#x60; - A point of interest, like e.g. a shop, a service, or a museum.
    /// </summary>
    /// <value>Distinguishes different types of Locations:    * &#x60;LOCALITY&#x60; - Represents a locality (town, city or place).    * &#x60;POSTAL_CODE&#x60; - Represents a postal code area.    * &#x60;STREET&#x60; - Represents a street, or a section of a street.    * &#x60;EXACT_ADDRESS:&#x60; - An address that is contained exactly in the geocoding data.     * &#x60;INTERPOLATED_ADDRESS&#x60; - An address that was interpolated from an address range.     * &#x60;INTERSECTION&#x60; - An at-grade junction where two streets meet.     * &#x60;POINT_OF_INTEREST&#x60; - A point of interest, like e.g. a shop, a service, or a museum.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum LocationType
    {
        /// <summary>
        /// Enum LOCALITY for value: LOCALITY
        /// </summary>
        [EnumMember(Value = "LOCALITY")]
        LOCALITY = 1,
        /// <summary>
        /// Enum POSTAL_CODE for value: POSTAL_CODE
        /// </summary>
        [EnumMember(Value = "POSTAL_CODE")]
        POSTAL_CODE = 2,
        /// <summary>
        /// Enum STREET for value: STREET
        /// </summary>
        [EnumMember(Value = "STREET")]
        STREET = 3,
        /// <summary>
        /// Enum EXACT_ADDRESS for value: EXACT_ADDRESS
        /// </summary>
        [EnumMember(Value = "EXACT_ADDRESS")]
        EXACT_ADDRESS = 4,
        /// <summary>
        /// Enum INTERPOLATED_ADDRESS for value: INTERPOLATED_ADDRESS
        /// </summary>
        [EnumMember(Value = "INTERPOLATED_ADDRESS")]
        INTERPOLATED_ADDRESS = 5,
        /// <summary>
        /// Enum INTERSECTION for value: INTERSECTION
        /// </summary>
        [EnumMember(Value = "INTERSECTION")]
        INTERSECTION = 6,
        /// <summary>
        /// Enum POINT_OF_INTEREST for value: POINT_OF_INTEREST
        /// </summary>
        [EnumMember(Value = "POINT_OF_INTEREST")]
        POINT_OF_INTEREST = 7
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// Place
    /// </summary>
    [DataContract(Name = "Place")]
    public partial class Place : IEquatable<Place>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Place" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Place() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Place" /> class.
        /// </summary>
        /// <param name="referencePosition">referencePosition (required).</param>
        /// <param name="roadAccessPosition">roadAccessPosition.</param>
        /// <param name="address">address (required).</param>
        /// <param name="formattedAddress">A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address..</param>
        /// <param name="name">The name of the place..</param>
        /// <param name="categoryIds">An array of place category IDs representing the categories this place is assigned to. (required).</param>
        /// <param name="quality">quality (required).</param>
        public Place(ReferencePosition referencePosition = default(ReferencePosition), RoadAccessPosition roadAccessPosition = default(RoadAccessPosition), Address address = default(Address), string formattedAddress = default(string), string name = default(string), List<string> categoryIds = default(List<string>), Quality quality = default(Quality))
        {
            // to ensure "referencePosition" is required (not null)
            if (referencePosition == null)
            {
                throw new ArgumentNullException("referencePosition is a required property for Place and cannot be null");
            }
            this.ReferencePosition = referencePosition;
            // to ensure "address" is required (not null)
            if (address == null)
            {
                throw new ArgumentNullException("address is a required property for Place and cannot be null");
            }
            this.Address = address;
            // to ensure "categoryIds" is required (not null)
            if (categoryIds == null)
            {
                throw new ArgumentNullException("categoryIds is a required property for Place and cannot be null");
            }
            this.CategoryIds = categoryIds;
            // to ensure "quality" is required (not null)
            if (quality == null)
            {
                throw new ArgumentNullException("quality is a required property for Place and cannot be null");
            }
            this.Quality = quality;
            this.RoadAccessPosition = roadAccessPosition;
            this.FormattedAddress = formattedAddress;
            this.Name = name;
        }
        /// <summary>
        /// Gets or Sets ReferencePosition
        /// </summary>
        [DataMember(Name = "referencePosition", IsRequired = true, EmitDefaultValue = false)]
        public ReferencePosition ReferencePosition { get; set; }
        /// <summary>
        /// Gets or Sets RoadAccessPosition
        /// </summary>
        [DataMember(Name = "roadAccessPosition", EmitDefaultValue = false)]
        public RoadAccessPosition RoadAccessPosition { get; set; }
        /// <summary>
        /// Gets or Sets Address
        /// </summary>
        [DataMember(Name = "address", IsRequired = true, EmitDefaultValue = false)]
        public Address Address { get; set; }
        /// <summary>
        /// A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address.
        /// </summary>
        /// <value>A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address.</value>
        [DataMember(Name = "formattedAddress", EmitDefaultValue = false)]
        public string FormattedAddress { get; set; }
        /// <summary>
        /// The name of the place.
        /// </summary>
        /// <value>The name of the place.</value>
        [DataMember(Name = "name", EmitDefaultValue = false)]
        public string Name { get; set; }
        /// <summary>
        /// An array of place category IDs representing the categories this place is assigned to.
        /// </summary>
        /// <value>An array of place category IDs representing the categories this place is assigned to.</value>
        [DataMember(Name = "categoryIds", IsRequired = true, EmitDefaultValue = false)]
        public List<string> CategoryIds { get; set; }
        /// <summary>
        /// Gets or Sets Quality
        /// </summary>
        [DataMember(Name = "quality", IsRequired = true, EmitDefaultValue = false)]
        public Quality Quality { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Place {\n");
            sb.Append("  ReferencePosition: ").Append(ReferencePosition).Append("\n");
            sb.Append("  RoadAccessPosition: ").Append(RoadAccessPosition).Append("\n");
            sb.Append("  Address: ").Append(Address).Append("\n");
            sb.Append("  FormattedAddress: ").Append(FormattedAddress).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  CategoryIds: ").Append(CategoryIds).Append("\n");
            sb.Append("  Quality: ").Append(Quality).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Place);
        }
        /// <summary>
        /// Returns true if Place instances are equal
        /// </summary>
        /// <param name="input">Instance of Place to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Place input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ReferencePosition == input.ReferencePosition ||
                    (this.ReferencePosition != null &&
                    this.ReferencePosition.Equals(input.ReferencePosition))
                ) && 
                (
                    this.RoadAccessPosition == input.RoadAccessPosition ||
                    (this.RoadAccessPosition != null &&
                    this.RoadAccessPosition.Equals(input.RoadAccessPosition))
                ) && 
                (
                    this.Address == input.Address ||
                    (this.Address != null &&
                    this.Address.Equals(input.Address))
                ) && 
                (
                    this.FormattedAddress == input.FormattedAddress ||
                    (this.FormattedAddress != null &&
                    this.FormattedAddress.Equals(input.FormattedAddress))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.CategoryIds == input.CategoryIds ||
                    this.CategoryIds != null &&
                    input.CategoryIds != null &&
                    this.CategoryIds.SequenceEqual(input.CategoryIds)
                ) && 
                (
                    this.Quality == input.Quality ||
                    (this.Quality != null &&
                    this.Quality.Equals(input.Quality))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ReferencePosition != null)
                {
                    hashCode = (hashCode * 59) + this.ReferencePosition.GetHashCode();
                }
                if (this.RoadAccessPosition != null)
                {
                    hashCode = (hashCode * 59) + this.RoadAccessPosition.GetHashCode();
                }
                if (this.Address != null)
                {
                    hashCode = (hashCode * 59) + this.Address.GetHashCode();
                }
                if (this.FormattedAddress != null)
                {
                    hashCode = (hashCode * 59) + this.FormattedAddress.GetHashCode();
                }
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.CategoryIds != null)
                {
                    hashCode = (hashCode * 59) + this.CategoryIds.GetHashCode();
                }
                if (this.Quality != null)
                {
                    hashCode = (hashCode * 59) + this.Quality.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// PlaceAllOf
    /// </summary>
    [DataContract(Name = "Place_allOf")]
    public partial class PlaceAllOf : IEquatable<PlaceAllOf>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PlaceAllOf" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected PlaceAllOf() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlaceAllOf" /> class.
        /// </summary>
        /// <param name="name">The name of the place..</param>
        /// <param name="categoryIds">An array of place category IDs representing the categories this place is assigned to. (required).</param>
        /// <param name="quality">quality (required).</param>
        public PlaceAllOf(string name = default(string), List<string> categoryIds = default(List<string>), Quality quality = default(Quality))
        {
            // to ensure "categoryIds" is required (not null)
            if (categoryIds == null)
            {
                throw new ArgumentNullException("categoryIds is a required property for PlaceAllOf and cannot be null");
            }
            this.CategoryIds = categoryIds;
            // to ensure "quality" is required (not null)
            if (quality == null)
            {
                throw new ArgumentNullException("quality is a required property for PlaceAllOf and cannot be null");
            }
            this.Quality = quality;
            this.Name = name;
        }
        /// <summary>
        /// The name of the place.
        /// </summary>
        /// <value>The name of the place.</value>
        [DataMember(Name = "name", EmitDefaultValue = false)]
        public string Name { get; set; }
        /// <summary>
        /// An array of place category IDs representing the categories this place is assigned to.
        /// </summary>
        /// <value>An array of place category IDs representing the categories this place is assigned to.</value>
        [DataMember(Name = "categoryIds", IsRequired = true, EmitDefaultValue = false)]
        public List<string> CategoryIds { get; set; }
        /// <summary>
        /// Gets or Sets Quality
        /// </summary>
        [DataMember(Name = "quality", IsRequired = true, EmitDefaultValue = false)]
        public Quality Quality { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PlaceAllOf {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  CategoryIds: ").Append(CategoryIds).Append("\n");
            sb.Append("  Quality: ").Append(Quality).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PlaceAllOf);
        }
        /// <summary>
        /// Returns true if PlaceAllOf instances are equal
        /// </summary>
        /// <param name="input">Instance of PlaceAllOf to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PlaceAllOf input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.CategoryIds == input.CategoryIds ||
                    this.CategoryIds != null &&
                    input.CategoryIds != null &&
                    this.CategoryIds.SequenceEqual(input.CategoryIds)
                ) && 
                (
                    this.Quality == input.Quality ||
                    (this.Quality != null &&
                    this.Quality.Equals(input.Quality))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.CategoryIds != null)
                {
                    hashCode = (hashCode * 59) + this.CategoryIds.GetHashCode();
                }
                if (this.Quality != null)
                {
                    hashCode = (hashCode * 59) + this.Quality.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// Response type for place category requests.
    /// </summary>
    [DataContract(Name = "PlaceCategories")]
    public partial class PlaceCategories : IEquatable<PlaceCategories>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PlaceCategories" /> class.
        /// </summary>
        /// <param name="placeCategories">The individual place categories..</param>
        public PlaceCategories(List<PlaceCategory> placeCategories = default(List<PlaceCategory>))
        {
            this._PlaceCategories = placeCategories;
        }
        /// <summary>
        /// The individual place categories.
        /// </summary>
        /// <value>The individual place categories.</value>
        [DataMember(Name = "placeCategories", EmitDefaultValue = false)]
        public List<PlaceCategory> _PlaceCategories { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PlaceCategories {\n");
            sb.Append("  _PlaceCategories: ").Append(_PlaceCategories).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PlaceCategories);
        }
        /// <summary>
        /// Returns true if PlaceCategories instances are equal
        /// </summary>
        /// <param name="input">Instance of PlaceCategories to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PlaceCategories input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this._PlaceCategories == input._PlaceCategories ||
                    this._PlaceCategories != null &&
                    input._PlaceCategories != null &&
                    this._PlaceCategories.SequenceEqual(input._PlaceCategories)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this._PlaceCategories != null)
                {
                    hashCode = (hashCode * 59) + this._PlaceCategories.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// PlaceCategory
    /// </summary>
    [DataContract(Name = "PlaceCategory")]
    public partial class PlaceCategory : IEquatable<PlaceCategory>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PlaceCategory" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected PlaceCategory() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlaceCategory" /> class.
        /// </summary>
        /// <param name="id">The identifier string of the category. (required).</param>
        /// <param name="name">A human readable name for the category..</param>
        /// <param name="description">An explanation of what kind of places are part of this category..</param>
        public PlaceCategory(string id = default(string), string name = default(string), string description = default(string))
        {
            // to ensure "id" is required (not null)
            if (id == null)
            {
                throw new ArgumentNullException("id is a required property for PlaceCategory and cannot be null");
            }
            this.Id = id;
            this.Name = name;
            this.Description = description;
        }
        /// <summary>
        /// The identifier string of the category.
        /// </summary>
        /// <value>The identifier string of the category.</value>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = false)]
        public string Id { get; set; }
        /// <summary>
        /// A human readable name for the category.
        /// </summary>
        /// <value>A human readable name for the category.</value>
        [DataMember(Name = "name", EmitDefaultValue = false)]
        public string Name { get; set; }
        /// <summary>
        /// An explanation of what kind of places are part of this category.
        /// </summary>
        /// <value>An explanation of what kind of places are part of this category.</value>
        [DataMember(Name = "description", EmitDefaultValue = false)]
        public string Description { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PlaceCategory {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PlaceCategory);
        }
        /// <summary>
        /// Returns true if PlaceCategory instances are equal
        /// </summary>
        /// <param name="input">Instance of PlaceCategory to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PlaceCategory input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Id != null)
                {
                    hashCode = (hashCode * 59) + this.Id.GetHashCode();
                }
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// PlacesByAreaRequest
    /// </summary>
    [DataContract(Name = "PlacesByAreaRequest")]
    public partial class PlacesByAreaRequest : IEquatable<PlacesByAreaRequest>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesByAreaRequest" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected PlacesByAreaRequest() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesByAreaRequest" /> class.
        /// </summary>
        /// <param name="area">area (required).</param>
        public PlacesByAreaRequest(Area area = default(Area))
        {
            // to ensure "area" is required (not null)
            if (area == null)
            {
                throw new ArgumentNullException("area is a required property for PlacesByAreaRequest and cannot be null");
            }
            this.Area = area;
        }
        /// <summary>
        /// Gets or Sets Area
        /// </summary>
        [DataMember(Name = "area", IsRequired = true, EmitDefaultValue = false)]
        public Area Area { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PlacesByAreaRequest {\n");
            sb.Append("  Area: ").Append(Area).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PlacesByAreaRequest);
        }
        /// <summary>
        /// Returns true if PlacesByAreaRequest instances are equal
        /// </summary>
        /// <param name="input">Instance of PlacesByAreaRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PlacesByAreaRequest input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Area == input.Area ||
                    (this.Area != null &&
                    this.Area.Equals(input.Area))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Area != null)
                {
                    hashCode = (hashCode * 59) + this.Area.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// The result of a places search.
    /// </summary>
    [DataContract(Name = "PlacesSearchResult")]
    public partial class PlacesSearchResult : IEquatable<PlacesSearchResult>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesSearchResult" /> class.
        /// </summary>
        /// <param name="places">The found places..</param>
        /// <param name="warnings">A list of warnings concerning the validity of the result..</param>
        public PlacesSearchResult(List<Place> places = default(List<Place>), List<Warning> warnings = default(List<Warning>))
        {
            this.Places = places;
            this.Warnings = warnings;
        }
        /// <summary>
        /// The found places.
        /// </summary>
        /// <value>The found places.</value>
        [DataMember(Name = "places", EmitDefaultValue = false)]
        public List<Place> Places { get; set; }
        /// <summary>
        /// A list of warnings concerning the validity of the result.
        /// </summary>
        /// <value>A list of warnings concerning the validity of the result.</value>
        [DataMember(Name = "warnings", EmitDefaultValue = false)]
        public List<Warning> Warnings { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PlacesSearchResult {\n");
            sb.Append("  Places: ").Append(Places).Append("\n");
            sb.Append("  Warnings: ").Append(Warnings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PlacesSearchResult);
        }
        /// <summary>
        /// Returns true if PlacesSearchResult instances are equal
        /// </summary>
        /// <param name="input">Instance of PlacesSearchResult to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PlacesSearchResult input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Places == input.Places ||
                    this.Places != null &&
                    input.Places != null &&
                    this.Places.SequenceEqual(input.Places)
                ) && 
                (
                    this.Warnings == input.Warnings ||
                    this.Warnings != null &&
                    input.Warnings != null &&
                    this.Warnings.SequenceEqual(input.Warnings)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Places != null)
                {
                    hashCode = (hashCode * 59) + this.Places.GetHashCode();
                }
                if (this.Warnings != null)
                {
                    hashCode = (hashCode * 59) + this.Warnings.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// Quality indicators that help deciding how well a result fits to the search input.
    /// </summary>
    [DataContract(Name = "Quality")]
    public partial class Quality : IEquatable<Quality>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Quality" /> class.
        /// </summary>
        /// <param name="distance">The spatial distance in \\[m\\] between the location or the place and the input of a position search.    This is only available for **searchLocationsByPosition** and **searchPlacesByPosition**..</param>
        /// <param name="totalScore">An overall score in \\[%\\] for address searches. 100 percent represents a perfect match between the input and the result.    This is only available for **searchLocationsByText** and **searchLocationsByAddress** results..</param>
        public Quality(int? distance = default(int?), int? totalScore = default(int?))
        {
            this.Distance = distance;
            this.TotalScore = totalScore;
        }
        /// <summary>
        /// The spatial distance in \\[m\\] between the location or the place and the input of a position search.    This is only available for **searchLocationsByPosition** and **searchPlacesByPosition**.
        /// </summary>
        /// <value>The spatial distance in \\[m\\] between the location or the place and the input of a position search.    This is only available for **searchLocationsByPosition** and **searchPlacesByPosition**.</value>
        [DataMember(Name = "distance", EmitDefaultValue = true)]
        public int? Distance { get; set; }
        /// <summary>
        /// An overall score in \\[%\\] for address searches. 100 percent represents a perfect match between the input and the result.    This is only available for **searchLocationsByText** and **searchLocationsByAddress** results.
        /// </summary>
        /// <value>An overall score in \\[%\\] for address searches. 100 percent represents a perfect match between the input and the result.    This is only available for **searchLocationsByText** and **searchLocationsByAddress** results.</value>
        [DataMember(Name = "totalScore", EmitDefaultValue = true)]
        public int? TotalScore { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Quality {\n");
            sb.Append("  Distance: ").Append(Distance).Append("\n");
            sb.Append("  TotalScore: ").Append(TotalScore).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Quality);
        }
        /// <summary>
        /// Returns true if Quality instances are equal
        /// </summary>
        /// <param name="input">Instance of Quality to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Quality input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Distance == input.Distance ||
                    (this.Distance != null &&
                    this.Distance.Equals(input.Distance))
                ) && 
                (
                    this.TotalScore == input.TotalScore ||
                    (this.TotalScore != null &&
                    this.TotalScore.Equals(input.TotalScore))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Distance != null)
                {
                    hashCode = (hashCode * 59) + this.Distance.GetHashCode();
                }
                if (this.TotalScore != null)
                {
                    hashCode = (hashCode * 59) + this.TotalScore.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// The actual position of the object itself, such as the rooftop of a building, the center of a street, or the reference position of a city.
    /// </summary>
    [DataContract(Name = "ReferencePosition")]
    public partial class ReferencePosition : IEquatable<ReferencePosition>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReferencePosition" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ReferencePosition() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReferencePosition" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        public ReferencePosition(double latitude = default(double), double longitude = default(double))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = false)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = false)]
        public double Longitude { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReferencePosition {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReferencePosition);
        }
        /// <summary>
        /// Returns true if ReferencePosition instances are equal
        /// </summary>
        /// <param name="input">Instance of ReferencePosition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReferencePosition input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// A position on or very close to a road that marks the entry to the object. Available only for objects which represent buildings with a complete address and only if present in the data.    The road from which the object can be accessed is not necessarily the road which is closest to the object.
    /// </summary>
    [DataContract(Name = "RoadAccessPosition")]
    public partial class RoadAccessPosition : IEquatable<RoadAccessPosition>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RoadAccessPosition" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected RoadAccessPosition() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RoadAccessPosition" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        public RoadAccessPosition(double latitude = default(double), double longitude = default(double))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = false)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = false)]
        public double Longitude { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RoadAccessPosition {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RoadAccessPosition);
        }
        /// <summary>
        /// Returns true if RoadAccessPosition instances are equal
        /// </summary>
        /// <param name="input">Instance of RoadAccessPosition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RoadAccessPosition input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            yield break;
        }
    }
}
/*
 * Geocoding
 *
 * With the Geocoding service you can find locations by converting street addresses into GPS-coordinates and vice versa. The Places service allows to search for millions of shops and prominent points of interest in various categories.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace GeocodingClient.Model
{
    /// <summary>
    /// Warning
    /// </summary>
    [DataContract(Name = "Warning")]
    public partial class Warning : IEquatable<Warning>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Warning" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Warning() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Warning" /> class.
        /// </summary>
        /// <param name="description">A human readable message that describes the warning. (required).</param>
        /// <param name="warningCode">A constant string that can be used to identify this warning class programmatically. A warningCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.    Note that additional warningCodes as well as the **details** of existing warningCodes may be added at any time. Furthermore, the **description** may change at any time.    * &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; - A given code in **countryFilter** referring to a subdivision of a country was modified to its corresponding country code.     * &#x60;requestedSubdivisionCode&#x60; - The subdivision code that was originally requested.     * &#x60;fallbackCountryCode&#x60; - The country code that was used as a fallback in the search.   * &#x60;GEOCODING_TIMEOUT&#x60; - The search ran into a timeout while trying to find results.   * &#x60;GEOCODING_INPUT_TOO_LONG&#x60; - The input was rejected because it is too long.     * &#x60;maximumSize&#x60; - The maximum allowed size of a singleField request.     * &#x60;GEOCODING_TOO_MANY_RESULTS&#x60; - Too many results found. Not all of them are provided in the response.   (required).</param>
        /// <param name="details">Additional properties specific to this class of warnings..</param>
        public Warning(string description = default(string), string warningCode = default(string), Dictionary<string, Object> details = default(Dictionary<string, Object>))
        {
            // to ensure "description" is required (not null)
            if (description == null)
            {
                throw new ArgumentNullException("description is a required property for Warning and cannot be null");
            }
            this.Description = description;
            // to ensure "warningCode" is required (not null)
            if (warningCode == null)
            {
                throw new ArgumentNullException("warningCode is a required property for Warning and cannot be null");
            }
            this.WarningCode = warningCode;
            this.Details = details;
        }
        /// <summary>
        /// A human readable message that describes the warning.
        /// </summary>
        /// <value>A human readable message that describes the warning.</value>
        [DataMember(Name = "description", IsRequired = true, EmitDefaultValue = false)]
        public string Description { get; set; }
        /// <summary>
        /// A constant string that can be used to identify this warning class programmatically. A warningCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.    Note that additional warningCodes as well as the **details** of existing warningCodes may be added at any time. Furthermore, the **description** may change at any time.    * &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; - A given code in **countryFilter** referring to a subdivision of a country was modified to its corresponding country code.     * &#x60;requestedSubdivisionCode&#x60; - The subdivision code that was originally requested.     * &#x60;fallbackCountryCode&#x60; - The country code that was used as a fallback in the search.   * &#x60;GEOCODING_TIMEOUT&#x60; - The search ran into a timeout while trying to find results.   * &#x60;GEOCODING_INPUT_TOO_LONG&#x60; - The input was rejected because it is too long.     * &#x60;maximumSize&#x60; - The maximum allowed size of a singleField request.     * &#x60;GEOCODING_TOO_MANY_RESULTS&#x60; - Too many results found. Not all of them are provided in the response.  
        /// </summary>
        /// <value>A constant string that can be used to identify this warning class programmatically. A warningCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified.    Note that additional warningCodes as well as the **details** of existing warningCodes may be added at any time. Furthermore, the **description** may change at any time.    * &#x60;GEOCODING_COUNTRY_FILTER_MODIFIED&#x60; - A given code in **countryFilter** referring to a subdivision of a country was modified to its corresponding country code.     * &#x60;requestedSubdivisionCode&#x60; - The subdivision code that was originally requested.     * &#x60;fallbackCountryCode&#x60; - The country code that was used as a fallback in the search.   * &#x60;GEOCODING_TIMEOUT&#x60; - The search ran into a timeout while trying to find results.   * &#x60;GEOCODING_INPUT_TOO_LONG&#x60; - The input was rejected because it is too long.     * &#x60;maximumSize&#x60; - The maximum allowed size of a singleField request.     * &#x60;GEOCODING_TOO_MANY_RESULTS&#x60; - Too many results found. Not all of them are provided in the response.  </value>
        [DataMember(Name = "warningCode", IsRequired = true, EmitDefaultValue = false)]
        public string WarningCode { get; set; }
        /// <summary>
        /// Additional properties specific to this class of warnings.
        /// </summary>
        /// <value>Additional properties specific to this class of warnings.</value>
        [DataMember(Name = "details", EmitDefaultValue = false)]
        public Dictionary<string, Object> Details { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Warning {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  WarningCode: ").Append(WarningCode).Append("\n");
            sb.Append("  Details: ").Append(Details).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Warning);
        }
        /// <summary>
        /// Returns true if Warning instances are equal
        /// </summary>
        /// <param name="input">Instance of Warning to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Warning input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.WarningCode == input.WarningCode ||
                    (this.WarningCode != null &&
                    this.WarningCode.Equals(input.WarningCode))
                ) && 
                (
                    this.Details == input.Details ||
                    this.Details != null &&
                    input.Details != null &&
                    this.Details.SequenceEqual(input.Details)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.WarningCode != null)
                {
                    hashCode = (hashCode * 59) + this.WarningCode.GetHashCode();
                }
                if (this.Details != null)
                {
                    hashCode = (hashCode * 59) + this.Details.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
